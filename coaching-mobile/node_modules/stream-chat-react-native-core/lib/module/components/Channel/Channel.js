var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reactionData = exports.Channel = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _debounce = _interopRequireDefault(require("lodash/debounce"));
var _throttle = _interopRequireDefault(require("lodash/throttle"));
var _mimeTypes = require("mime-types");
var _streamChat = require("stream-chat");
var _useChannelDataState2 = require("./hooks/useChannelDataState");
var _useCreateChannelContext = require("./hooks/useCreateChannelContext");
var _useCreateInputMessageInputContext = require("./hooks/useCreateInputMessageInputContext");
var _useCreateMessagesContext = require("./hooks/useCreateMessagesContext");
var _useCreateOwnCapabilitiesContext = require("./hooks/useCreateOwnCapabilitiesContext");
var _useCreatePaginatedMessageListContext = require("./hooks/useCreatePaginatedMessageListContext");
var _useCreateThreadContext = require("./hooks/useCreateThreadContext");
var _useCreateTypingContext = require("./hooks/useCreateTypingContext");
var _useMessageListPagination = require("./hooks/useMessageListPagination");
var _useTargetedMessage2 = require("./hooks/useTargetedMessage");
var _CameraSelectorIcon = require("../../components/AttachmentPicker/components/CameraSelectorIcon");
var _FileSelectorIcon = require("../../components/AttachmentPicker/components/FileSelectorIcon");
var _ImageSelectorIcon = require("../../components/AttachmentPicker/components/ImageSelectorIcon");
var _VideoRecorderSelectorIcon = require("../../components/AttachmentPicker/components/VideoRecorderSelectorIcon");
var _CreatePollIcon = require("../../components/Poll/components/CreatePollIcon");
var _contexts = require("../../contexts");
var _ChannelContext = require("../../contexts/channelContext/ChannelContext");
var _useChannelState2 = require("../../contexts/channelsStateContext/useChannelState");
var _ChatContext = require("../../contexts/chatContext/ChatContext");
var _MessageComposerContext = require("../../contexts/messageComposerContext/MessageComposerContext");
var _MessageInputContext = require("../../contexts/messageInputContext/MessageInputContext");
var _MessagesContext = require("../../contexts/messagesContext/MessagesContext");
var _OwnCapabilitiesContext = require("../../contexts/ownCapabilitiesContext/OwnCapabilitiesContext");
var _PaginatedMessageListContext = require("../../contexts/paginatedMessageListContext/PaginatedMessageListContext");
var _ThemeContext = require("../../contexts/themeContext/ThemeContext");
var _ThreadContext = require("../../contexts/threadContext/ThreadContext");
var _TranslationContext = require("../../contexts/translationContext/TranslationContext");
var _TypingContext = require("../../contexts/typingContext/TypingContext");
var _hooks = require("../../hooks");
var _useAppStateListener = require("../../hooks/useAppStateListener");
var _useAttachmentPickerBottomSheet = require("../../hooks/useAttachmentPickerBottomSheet");
var _icons = require("../../icons");
var _native = require("../../native");
var dbApi = _interopRequireWildcard(require("../../store/apis"));
var _types = require("../../types/types");
var _addReactionToLocalState = require("../../utils/addReactionToLocalState");
var _compressImage = require("../../utils/compressImage");
var _patchMessageTextCommand = require("../../utils/patchMessageTextCommand");
var _utils = require("../../utils/utils");
var _Attachment = require("../Attachment/Attachment");
var _AttachmentActions = require("../Attachment/AttachmentActions");
var _AudioAttachment = require("../Attachment/AudioAttachment");
var _Card = require("../Attachment/Card");
var _FileAttachment = require("../Attachment/FileAttachment");
var _FileAttachmentGroup = require("../Attachment/FileAttachmentGroup");
var _FileIcon = require("../Attachment/FileIcon");
var _Gallery = require("../Attachment/Gallery");
var _Giphy = require("../Attachment/Giphy");
var _ImageLoadingFailedIndicator = require("../Attachment/ImageLoadingFailedIndicator");
var _ImageLoadingIndicator = require("../Attachment/ImageLoadingIndicator");
var _ImageReloadIndicator = require("../Attachment/ImageReloadIndicator");
var _VideoThumbnail = require("../Attachment/VideoThumbnail");
var _AttachmentPicker = require("../AttachmentPicker/AttachmentPicker");
var _AttachmentPickerBottomSheetHandle = require("../AttachmentPicker/components/AttachmentPickerBottomSheetHandle");
var _AttachmentPickerError = require("../AttachmentPicker/components/AttachmentPickerError");
var _AttachmentPickerErrorImage = require("../AttachmentPicker/components/AttachmentPickerErrorImage");
var _AttachmentPickerIOSSelectMorePhotos = require("../AttachmentPicker/components/AttachmentPickerIOSSelectMorePhotos");
var _AttachmentPickerSelectionBar = require("../AttachmentPicker/components/AttachmentPickerSelectionBar");
var _ImageOverlaySelectedComponent = require("../AttachmentPicker/components/ImageOverlaySelectedComponent");
var _AutoCompleteSuggestionHeader = require("../AutoCompleteInput/AutoCompleteSuggestionHeader");
var _AutoCompleteSuggestionItem = require("../AutoCompleteInput/AutoCompleteSuggestionItem");
var _AutoCompleteSuggestionList = require("../AutoCompleteInput/AutoCompleteSuggestionList");
var _EmptyStateIndicator = require("../Indicators/EmptyStateIndicator");
var _LoadingErrorIndicator = require("../Indicators/LoadingErrorIndicator");
var _LoadingIndicator = require("../Indicators/LoadingIndicator");
var _KeyboardCompatibleView = require("../KeyboardCompatibleView/KeyboardCompatibleView");
var _Message = require("../Message/Message");
var _MessageAvatar = require("../Message/MessageSimple/MessageAvatar");
var _MessageBounce = require("../Message/MessageSimple/MessageBounce");
var _MessageContent = require("../Message/MessageSimple/MessageContent");
var _MessageDeleted = require("../Message/MessageSimple/MessageDeleted");
var _MessageEditedTimestamp = require("../Message/MessageSimple/MessageEditedTimestamp");
var _MessageError = require("../Message/MessageSimple/MessageError");
var _MessageFooter = require("../Message/MessageSimple/MessageFooter");
var _MessagePinnedHeader = require("../Message/MessageSimple/MessagePinnedHeader");
var _MessageReplies = require("../Message/MessageSimple/MessageReplies");
var _MessageRepliesAvatars = require("../Message/MessageSimple/MessageRepliesAvatars");
var _MessageSimple = require("../Message/MessageSimple/MessageSimple");
var _MessageStatus = require("../Message/MessageSimple/MessageStatus");
var _MessageSwipeContent = require("../Message/MessageSimple/MessageSwipeContent");
var _MessageTimestamp = require("../Message/MessageSimple/MessageTimestamp");
var _ReactionListBottom = require("../Message/MessageSimple/ReactionList/ReactionListBottom");
var _ReactionListTop = require("../Message/MessageSimple/ReactionList/ReactionListTop");
var _StreamingMessageView = require("../Message/MessageSimple/StreamingMessageView");
var _AttachButton = require("../MessageInput/AttachButton");
var _AttachmentUploadPreviewList = require("../MessageInput/AttachmentUploadPreviewList");
var _CommandsButton = require("../MessageInput/CommandsButton");
var _AttachmentUploadProgressIndicator = require("../MessageInput/components/AttachmentPreview/AttachmentUploadProgressIndicator");
var _AudioAttachmentUploadPreview = require("../MessageInput/components/AttachmentPreview/AudioAttachmentUploadPreview");
var _FileAttachmentUploadPreview = require("../MessageInput/components/AttachmentPreview/FileAttachmentUploadPreview");
var _ImageAttachmentUploadPreview = require("../MessageInput/components/AttachmentPreview/ImageAttachmentUploadPreview");
var _AudioRecorder = require("../MessageInput/components/AudioRecorder/AudioRecorder");
var _AudioRecordingButton = require("../MessageInput/components/AudioRecorder/AudioRecordingButton");
var _AudioRecordingInProgress = require("../MessageInput/components/AudioRecorder/AudioRecordingInProgress");
var _AudioRecordingLockIndicator = require("../MessageInput/components/AudioRecorder/AudioRecordingLockIndicator");
var _AudioRecordingPreview = require("../MessageInput/components/AudioRecorder/AudioRecordingPreview");
var _AudioRecordingWaveform = require("../MessageInput/components/AudioRecorder/AudioRecordingWaveform");
var _CommandInput = require("../MessageInput/components/CommandInput");
var _InputEditingStateHeader = require("../MessageInput/components/InputEditingStateHeader");
var _InputReplyStateHeader = require("../MessageInput/components/InputReplyStateHeader");
var _CooldownTimer = require("../MessageInput/CooldownTimer");
var _InputButtons = require("../MessageInput/InputButtons");
var _MoreOptionsButton = require("../MessageInput/MoreOptionsButton");
var _SendButton = require("../MessageInput/SendButton");
var _SendMessageDisallowedIndicator = require("../MessageInput/SendMessageDisallowedIndicator");
var _ShowThreadMessageInChannelButton = require("../MessageInput/ShowThreadMessageInChannelButton");
var _StopMessageStreamingButton = require("../MessageInput/StopMessageStreamingButton");
var _DateHeader = require("../MessageList/DateHeader");
var _InlineDateSeparator = require("../MessageList/InlineDateSeparator");
var _InlineUnreadIndicator = require("../MessageList/InlineUnreadIndicator");
var _MessageList = require("../MessageList/MessageList");
var _MessageSystem = require("../MessageList/MessageSystem");
var _NetworkDownIndicator = require("../MessageList/NetworkDownIndicator");
var _ScrollToBottomButton = require("../MessageList/ScrollToBottomButton");
var _StickyHeader = require("../MessageList/StickyHeader");
var _TypingIndicator = require("../MessageList/TypingIndicator");
var _TypingIndicatorContainer = require("../MessageList/TypingIndicatorContainer");
var _UnreadMessagesNotification = require("../MessageList/UnreadMessagesNotification");
var _MessageActionList = require("../MessageMenu/MessageActionList");
var _MessageActionListItem = require("../MessageMenu/MessageActionListItem");
var _MessageMenu = require("../MessageMenu/MessageMenu");
var _MessageReactionPicker = require("../MessageMenu/MessageReactionPicker");
var _MessageUserReactions = require("../MessageMenu/MessageUserReactions");
var _MessageUserReactionsAvatar = require("../MessageMenu/MessageUserReactionsAvatar");
var _MessageUserReactionsItem = require("../MessageMenu/MessageUserReactionsItem");
var _Reply = require("../Reply/Reply");
var _jsxRuntime = require("react/jsx-runtime");
var _excluded = ["user"],
  _excluded2 = ["user"];
var _this = this,
  _jsxFileName = "/home/runner/work/stream-chat-react-native/stream-chat-react-native/package/src/components/Channel/Channel.tsx";
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var styles = _reactNative.StyleSheet.create({
  selectChannel: {
    fontWeight: 'bold',
    padding: 16
  }
});
var reactionData = exports.reactionData = [{
  Icon: _icons.LoveReaction,
  type: 'love'
}, {
  Icon: _icons.ThumbsUpReaction,
  type: 'like'
}, {
  Icon: _icons.ThumbsDownReaction,
  type: 'sad'
}, {
  Icon: _icons.LOLReaction,
  type: 'haha'
}, {
  Icon: _icons.WutReaction,
  type: 'wow'
}];
var scrollToFirstUnreadThreshold = 0;
var defaultThrottleInterval = 500;
var defaultDebounceInterval = 500;
var throttleOptions = {
  leading: true,
  trailing: true
};
var debounceOptions = {
  leading: true,
  trailing: true
};
var ChannelWithContext = function ChannelWithContext(props) {
  var _channel$getConfig, _channel$data, _channelState$members, _channelState$read, _clientChannelConfig$, _channelMessagesState2, _channelState$typing, _channelMessagesState3;
  var _useViewport = (0, _hooks.useViewport)(),
    vh = _useViewport.vh;
  var additionalKeyboardAvoidingViewProps = props.additionalKeyboardAvoidingViewProps,
    additionalPressableProps = props.additionalPressableProps,
    additionalTextInputProps = props.additionalTextInputProps,
    _props$allowThreadMes = props.allowThreadMessagesInChannel,
    allowThreadMessagesInChannel = _props$allowThreadMes === void 0 ? true : _props$allowThreadMes,
    _props$asyncMessagesL = props.asyncMessagesLockDistance,
    asyncMessagesLockDistance = _props$asyncMessagesL === void 0 ? 50 : _props$asyncMessagesL,
    _props$asyncMessagesM = props.asyncMessagesMinimumPressDuration,
    asyncMessagesMinimumPressDuration = _props$asyncMessagesM === void 0 ? 500 : _props$asyncMessagesM,
    _props$asyncMessagesM2 = props.asyncMessagesMultiSendEnabled,
    asyncMessagesMultiSendEnabled = _props$asyncMessagesM2 === void 0 ? true : _props$asyncMessagesM2,
    _props$asyncMessagesS = props.asyncMessagesSlideToCancelDistance,
    asyncMessagesSlideToCancelDistance = _props$asyncMessagesS === void 0 ? 100 : _props$asyncMessagesS,
    _props$AttachButton = props.AttachButton,
    AttachButton = _props$AttachButton === void 0 ? _AttachButton.AttachButton : _props$AttachButton,
    _props$Attachment = props.Attachment,
    Attachment = _props$Attachment === void 0 ? _Attachment.Attachment : _props$Attachment,
    _props$AttachmentActi = props.AttachmentActions,
    AttachmentActions = _props$AttachmentActi === void 0 ? _AttachmentActions.AttachmentActions : _props$AttachmentActi,
    _props$AttachmentPick = props.AttachmentPickerBottomSheetHandle,
    AttachmentPickerBottomSheetHandle = _props$AttachmentPick === void 0 ? _AttachmentPickerBottomSheetHandle.AttachmentPickerBottomSheetHandle : _props$AttachmentPick,
    _props$attachmentPick = props.attachmentPickerBottomSheetHandleHeight,
    attachmentPickerBottomSheetHandleHeight = _props$attachmentPick === void 0 ? 20 : _props$attachmentPick,
    _props$attachmentPick2 = props.attachmentPickerBottomSheetHeight,
    attachmentPickerBottomSheetHeight = _props$attachmentPick2 === void 0 ? vh(45) : _props$attachmentPick2,
    _props$AttachmentPick2 = props.AttachmentPickerSelectionBar,
    AttachmentPickerSelectionBar = _props$AttachmentPick2 === void 0 ? _AttachmentPickerSelectionBar.AttachmentPickerSelectionBar : _props$AttachmentPick2,
    _props$attachmentSele = props.attachmentSelectionBarHeight,
    attachmentSelectionBarHeight = _props$attachmentSele === void 0 ? 52 : _props$attachmentSele,
    _props$AudioAttachmen = props.AudioAttachment,
    AudioAttachment = _props$AudioAttachmen === void 0 ? _AudioAttachment.AudioAttachment : _props$AudioAttachmen,
    _props$AudioAttachmen2 = props.AudioAttachmentUploadPreview,
    AudioAttachmentUploadPreview = _props$AudioAttachmen2 === void 0 ? _AudioAttachmentUploadPreview.AudioAttachmentUploadPreview : _props$AudioAttachmen2,
    _props$AudioRecorder = props.AudioRecorder,
    AudioRecorder = _props$AudioRecorder === void 0 ? _AudioRecorder.AudioRecorder : _props$AudioRecorder,
    _props$audioRecording = props.audioRecordingEnabled,
    audioRecordingEnabled = _props$audioRecording === void 0 ? false : _props$audioRecording,
    _props$AudioRecording = props.AudioRecordingInProgress,
    AudioRecordingInProgress = _props$AudioRecording === void 0 ? _AudioRecordingInProgress.AudioRecordingInProgress : _props$AudioRecording,
    _props$AudioRecording2 = props.AudioRecordingLockIndicator,
    AudioRecordingLockIndicator = _props$AudioRecording2 === void 0 ? _AudioRecordingLockIndicator.AudioRecordingLockIndicator : _props$AudioRecording2,
    _props$AudioRecording3 = props.AudioRecordingPreview,
    AudioRecordingPreview = _props$AudioRecording3 === void 0 ? _AudioRecordingPreview.AudioRecordingPreview : _props$AudioRecording3,
    _props$AudioRecording4 = props.AudioRecordingWaveform,
    AudioRecordingWaveform = _props$AudioRecording4 === void 0 ? _AudioRecordingWaveform.AudioRecordingWaveform : _props$AudioRecording4,
    _props$AutoCompleteSu = props.AutoCompleteSuggestionHeader,
    AutoCompleteSuggestionHeader = _props$AutoCompleteSu === void 0 ? _AutoCompleteSuggestionHeader.AutoCompleteSuggestionHeader : _props$AutoCompleteSu,
    _props$AutoCompleteSu2 = props.AutoCompleteSuggestionItem,
    AutoCompleteSuggestionItem = _props$AutoCompleteSu2 === void 0 ? _AutoCompleteSuggestionItem.AutoCompleteSuggestionItem : _props$AutoCompleteSu2,
    _props$AutoCompleteSu3 = props.AutoCompleteSuggestionList,
    AutoCompleteSuggestionList = _props$AutoCompleteSu3 === void 0 ? _AutoCompleteSuggestionList.AutoCompleteSuggestionList : _props$AutoCompleteSu3,
    _props$AttachmentPick3 = props.AttachmentPickerError,
    AttachmentPickerError = _props$AttachmentPick3 === void 0 ? _AttachmentPickerError.AttachmentPickerError : _props$AttachmentPick3,
    _props$AttachmentPick4 = props.AttachmentPickerErrorImage,
    AttachmentPickerErrorImage = _props$AttachmentPick4 === void 0 ? _AttachmentPickerErrorImage.AttachmentPickerErrorImage : _props$AttachmentPick4,
    _props$AttachmentPick5 = props.AttachmentPickerIOSSelectMorePhotos,
    AttachmentPickerIOSSelectMorePhotos = _props$AttachmentPick5 === void 0 ? _AttachmentPickerIOSSelectMorePhotos.AttachmentPickerIOSSelectMorePhotos : _props$AttachmentPick5,
    _props$AttachmentUplo = props.AttachmentUploadPreviewList,
    AttachmentUploadPreviewList = _props$AttachmentUplo === void 0 ? _AttachmentUploadPreviewList.AttachmentUploadPreviewList : _props$AttachmentUplo,
    _props$ImageOverlaySe = props.ImageOverlaySelectedComponent,
    ImageOverlaySelectedComponent = _props$ImageOverlaySe === void 0 ? _ImageOverlaySelectedComponent.ImageOverlaySelectedComponent : _props$ImageOverlaySe,
    attachmentPickerErrorButtonText = props.attachmentPickerErrorButtonText,
    attachmentPickerErrorText = props.attachmentPickerErrorText,
    _props$numberOfAttach = props.numberOfAttachmentImagesToLoadPerCall,
    numberOfAttachmentImagesToLoadPerCall = _props$numberOfAttach === void 0 ? 60 : _props$numberOfAttach,
    _props$numberOfAttach2 = props.numberOfAttachmentPickerImageColumns,
    numberOfAttachmentPickerImageColumns = _props$numberOfAttach2 === void 0 ? 3 : _props$numberOfAttach2,
    _props$bottomInset = props.bottomInset,
    bottomInset = _props$bottomInset === void 0 ? 0 : _props$bottomInset,
    _props$CameraSelector = props.CameraSelectorIcon,
    CameraSelectorIcon = _props$CameraSelector === void 0 ? _CameraSelectorIcon.CameraSelectorIcon : _props$CameraSelector,
    _props$FileSelectorIc = props.FileSelectorIcon,
    FileSelectorIcon = _props$FileSelectorIc === void 0 ? _FileSelectorIcon.FileSelectorIcon : _props$FileSelectorIc,
    _props$CreatePollIcon = props.CreatePollIcon,
    CreatePollIcon = _props$CreatePollIcon === void 0 ? _CreatePollIcon.CreatePollIcon : _props$CreatePollIcon,
    _props$ImageSelectorI = props.ImageSelectorIcon,
    ImageSelectorIcon = _props$ImageSelectorI === void 0 ? _ImageSelectorIcon.ImageSelectorIcon : _props$ImageSelectorI,
    _props$VideoRecorderS = props.VideoRecorderSelectorIcon,
    VideoRecorderSelectorIcon = _props$VideoRecorderS === void 0 ? _VideoRecorderSelectorIcon.VideoRecorderSelectorIcon : _props$VideoRecorderS,
    _props$Card = props.Card,
    Card = _props$Card === void 0 ? _Card.Card : _props$Card,
    CardCover = props.CardCover,
    CardFooter = props.CardFooter,
    CardHeader = props.CardHeader,
    channel = props.channel,
    children = props.children,
    client = props.client,
    _props$CommandsButton = props.CommandsButton,
    CommandsButton = _props$CommandsButton === void 0 ? _CommandsButton.CommandsButton : _props$CommandsButton,
    compressImageQuality = props.compressImageQuality,
    _props$CooldownTimer = props.CooldownTimer,
    CooldownTimer = _props$CooldownTimer === void 0 ? _CooldownTimer.CooldownTimer : _props$CooldownTimer,
    CreatePollContent = props.CreatePollContent,
    _props$DateHeader = props.DateHeader,
    DateHeader = _props$DateHeader === void 0 ? _DateHeader.DateHeader : _props$DateHeader,
    _props$deletedMessage = props.deletedMessagesVisibilityType,
    deletedMessagesVisibilityType = _props$deletedMessage === void 0 ? 'always' : _props$deletedMessage,
    _props$disableKeyboar = props.disableKeyboardCompatibleView,
    disableKeyboardCompatibleView = _props$disableKeyboar === void 0 ? false : _props$disableKeyboar,
    disableTypingIndicator = props.disableTypingIndicator,
    _props$dismissKeyboar = props.dismissKeyboardOnMessageTouch,
    dismissKeyboardOnMessageTouch = _props$dismissKeyboar === void 0 ? true : _props$dismissKeyboar,
    doFileUploadRequest = props.doFileUploadRequest,
    doMarkReadRequest = props.doMarkReadRequest,
    doSendMessageRequest = props.doSendMessageRequest,
    doUpdateMessageRequest = props.doUpdateMessageRequest,
    _props$EmptyStateIndi = props.EmptyStateIndicator,
    EmptyStateIndicator = _props$EmptyStateIndi === void 0 ? _EmptyStateIndicator.EmptyStateIndicator : _props$EmptyStateIndi,
    _props$enableMessageG = props.enableMessageGroupingByUser,
    enableMessageGroupingByUser = _props$enableMessageG === void 0 ? true : _props$enableMessageG,
    enableOfflineSupport = props.enableOfflineSupport,
    _props$enableSwipeToR = props.enableSwipeToReply,
    enableSwipeToReply = _props$enableSwipeToR === void 0 ? true : _props$enableSwipeToR,
    _props$enforceUniqueR = props.enforceUniqueReaction,
    enforceUniqueReaction = _props$enforceUniqueR === void 0 ? false : _props$enforceUniqueR,
    _props$FileAttachment = props.FileAttachment,
    FileAttachment = _props$FileAttachment === void 0 ? _FileAttachment.FileAttachment : _props$FileAttachment,
    _props$FileAttachment2 = props.FileAttachmentUploadPreview,
    FileAttachmentUploadPreview = _props$FileAttachment2 === void 0 ? _FileAttachmentUploadPreview.FileAttachmentUploadPreview : _props$FileAttachment2,
    _props$FileAttachment3 = props.FileAttachmentGroup,
    FileAttachmentGroup = _props$FileAttachment3 === void 0 ? _FileAttachmentGroup.FileAttachmentGroup : _props$FileAttachment3,
    _props$FileAttachment4 = props.FileAttachmentIcon,
    FileAttachmentIcon = _props$FileAttachment4 === void 0 ? _FileIcon.FileIcon : _props$FileAttachment4,
    _props$FlatList = props.FlatList,
    FlatList = _props$FlatList === void 0 ? _native.NativeHandlers.FlatList : _props$FlatList,
    forceAlignMessages = props.forceAlignMessages,
    _props$Gallery = props.Gallery,
    Gallery = _props$Gallery === void 0 ? _Gallery.Gallery : _props$Gallery,
    getMessagesGroupStyles = props.getMessagesGroupStyles,
    _props$Giphy = props.Giphy,
    Giphy = _props$Giphy === void 0 ? _Giphy.Giphy : _props$Giphy,
    _props$giphyVersion = props.giphyVersion,
    giphyVersion = _props$giphyVersion === void 0 ? 'fixed_height' : _props$giphyVersion,
    handleAttachButtonPress = props.handleAttachButtonPress,
    handleBan = props.handleBan,
    handleCopy = props.handleCopy,
    handleDelete = props.handleDelete,
    handleEdit = props.handleEdit,
    handleFlag = props.handleFlag,
    handleMarkUnread = props.handleMarkUnread,
    handleMute = props.handleMute,
    handlePinMessage = props.handlePinMessage,
    handleQuotedReply = props.handleQuotedReply,
    handleReaction = props.handleReaction,
    handleRetry = props.handleRetry,
    handleThreadReply = props.handleThreadReply,
    _props$hasCameraPicke = props.hasCameraPicker,
    hasCameraPicker = _props$hasCameraPicke === void 0 ? (0, _native.isImagePickerAvailable)() : _props$hasCameraPicke,
    hasCommands = props.hasCommands,
    hasCreatePoll = props.hasCreatePoll,
    _props$hasFilePicker = props.hasFilePicker,
    hasFilePicker = _props$hasFilePicker === void 0 ? (0, _native.isDocumentPickerAvailable)() : _props$hasFilePicker,
    _props$hasImagePicker = props.hasImagePicker,
    hasImagePicker = _props$hasImagePicker === void 0 ? (0, _native.isImagePickerAvailable)() || (0, _native.isImageMediaLibraryAvailable)() : _props$hasImagePicker,
    _props$hideDateSepara = props.hideDateSeparators,
    hideDateSeparators = _props$hideDateSepara === void 0 ? false : _props$hideDateSepara,
    _props$hideStickyDate = props.hideStickyDateHeader,
    hideStickyDateHeader = _props$hideStickyDate === void 0 ? false : _props$hideStickyDate,
    _props$ImageAttachmen = props.ImageAttachmentUploadPreview,
    ImageAttachmentUploadPreview = _props$ImageAttachmen === void 0 ? _ImageAttachmentUploadPreview.ImageAttachmentUploadPreview : _props$ImageAttachmen,
    _props$ImageLoadingFa = props.ImageLoadingFailedIndicator,
    ImageLoadingFailedIndicator = _props$ImageLoadingFa === void 0 ? _ImageLoadingFailedIndicator.ImageLoadingFailedIndicator : _props$ImageLoadingFa,
    _props$ImageLoadingIn = props.ImageLoadingIndicator,
    ImageLoadingIndicator = _props$ImageLoadingIn === void 0 ? _ImageLoadingIndicator.ImageLoadingIndicator : _props$ImageLoadingIn,
    _props$ImageReloadInd = props.ImageReloadIndicator,
    ImageReloadIndicator = _props$ImageReloadInd === void 0 ? _ImageReloadIndicator.ImageReloadIndicator : _props$ImageReloadInd,
    _props$initialScrollT = props.initialScrollToFirstUnreadMessage,
    initialScrollToFirstUnreadMessage = _props$initialScrollT === void 0 ? false : _props$initialScrollT,
    _props$InlineDateSepa = props.InlineDateSeparator,
    InlineDateSeparator = _props$InlineDateSepa === void 0 ? _InlineDateSeparator.InlineDateSeparator : _props$InlineDateSepa,
    _props$InlineUnreadIn = props.InlineUnreadIndicator,
    InlineUnreadIndicator = _props$InlineUnreadIn === void 0 ? _InlineUnreadIndicator.InlineUnreadIndicator : _props$InlineUnreadIn,
    Input = props.Input,
    _props$InputButtons = props.InputButtons,
    InputButtons = _props$InputButtons === void 0 ? _InputButtons.InputButtons : _props$InputButtons,
    _props$InputEditingSt = props.InputEditingStateHeader,
    InputEditingStateHeader = _props$InputEditingSt === void 0 ? _InputEditingStateHeader.InputEditingStateHeader : _props$InputEditingSt,
    _props$CommandInput = props.CommandInput,
    CommandInput = _props$CommandInput === void 0 ? _CommandInput.CommandInput : _props$CommandInput,
    _props$InputReplyStat = props.InputReplyStateHeader,
    InputReplyStateHeader = _props$InputReplyStat === void 0 ? _InputReplyStateHeader.InputReplyStateHeader : _props$InputReplyStat,
    isAttachmentEqual = props.isAttachmentEqual,
    _props$isMessageAIGen = props.isMessageAIGenerated,
    isMessageAIGenerated = _props$isMessageAIGen === void 0 ? function () {
      return false;
    } : _props$isMessageAIGen,
    keyboardBehavior = props.keyboardBehavior,
    _props$KeyboardCompat = props.KeyboardCompatibleView,
    KeyboardCompatibleView = _props$KeyboardCompat === void 0 ? _KeyboardCompatibleView.KeyboardCompatibleView : _props$KeyboardCompat,
    keyboardVerticalOffset = props.keyboardVerticalOffset,
    _props$legacyImageVie = props.legacyImageViewerSwipeBehaviour,
    legacyImageViewerSwipeBehaviour = _props$legacyImageVie === void 0 ? false : _props$legacyImageVie,
    _props$LoadingErrorIn = props.LoadingErrorIndicator,
    LoadingErrorIndicator = _props$LoadingErrorIn === void 0 ? _LoadingErrorIndicator.LoadingErrorIndicator : _props$LoadingErrorIn,
    _props$LoadingIndicat = props.LoadingIndicator,
    LoadingIndicator = _props$LoadingIndicat === void 0 ? _LoadingIndicator.LoadingIndicator : _props$LoadingIndicat,
    loadingMoreProp = props.loadingMore,
    loadingMoreRecentProp = props.loadingMoreRecent,
    markdownRules = props.markdownRules,
    _props$markReadOnMoun = props.markReadOnMount,
    markReadOnMount = _props$markReadOnMoun === void 0 ? true : _props$markReadOnMoun,
    maxTimeBetweenGroupedMessages = props.maxTimeBetweenGroupedMessages,
    _props$Message = props.Message,
    Message = _props$Message === void 0 ? _Message.Message : _props$Message,
    _props$MessageActionL = props.MessageActionList,
    MessageActionList = _props$MessageActionL === void 0 ? _MessageActionList.MessageActionList : _props$MessageActionL,
    _props$MessageActionL2 = props.MessageActionListItem,
    MessageActionListItem = _props$MessageActionL2 === void 0 ? _MessageActionListItem.MessageActionListItem : _props$MessageActionL2,
    messageActions = props.messageActions,
    _props$MessageAvatar = props.MessageAvatar,
    MessageAvatar = _props$MessageAvatar === void 0 ? _MessageAvatar.MessageAvatar : _props$MessageAvatar,
    _props$MessageBounce = props.MessageBounce,
    MessageBounce = _props$MessageBounce === void 0 ? _MessageBounce.MessageBounce : _props$MessageBounce,
    _props$MessageContent = props.MessageContent,
    MessageContent = _props$MessageContent === void 0 ? _MessageContent.MessageContent : _props$MessageContent,
    _props$messageContent = props.messageContentOrder,
    messageContentOrder = _props$messageContent === void 0 ? ['quoted_reply', 'gallery', 'files', 'poll', 'ai_text', 'text', 'attachments'] : _props$messageContent,
    _props$MessageDeleted = props.MessageDeleted,
    MessageDeleted = _props$MessageDeleted === void 0 ? _MessageDeleted.MessageDeleted : _props$MessageDeleted,
    _props$MessageEditedT = props.MessageEditedTimestamp,
    MessageEditedTimestamp = _props$MessageEditedT === void 0 ? _MessageEditedTimestamp.MessageEditedTimestamp : _props$MessageEditedT,
    _props$MessageError = props.MessageError,
    MessageError = _props$MessageError === void 0 ? _MessageError.MessageError : _props$MessageError,
    _props$MessageFooter = props.MessageFooter,
    MessageFooter = _props$MessageFooter === void 0 ? _MessageFooter.MessageFooter : _props$MessageFooter,
    MessageHeader = props.MessageHeader,
    messageId = props.messageId,
    _props$MessageList = props.MessageList,
    MessageList = _props$MessageList === void 0 ? _MessageList.MessageList : _props$MessageList,
    _props$MessageMenu = props.MessageMenu,
    MessageMenu = _props$MessageMenu === void 0 ? _MessageMenu.MessageMenu : _props$MessageMenu,
    _props$MessagePinnedH = props.MessagePinnedHeader,
    MessagePinnedHeader = _props$MessagePinnedH === void 0 ? _MessagePinnedHeader.MessagePinnedHeader : _props$MessagePinnedH,
    _props$MessageReactio = props.MessageReactionPicker,
    MessageReactionPicker = _props$MessageReactio === void 0 ? _MessageReactionPicker.MessageReactionPicker : _props$MessageReactio,
    _props$MessageReplies = props.MessageReplies,
    MessageReplies = _props$MessageReplies === void 0 ? _MessageReplies.MessageReplies : _props$MessageReplies,
    _props$MessageReplies2 = props.MessageRepliesAvatars,
    MessageRepliesAvatars = _props$MessageReplies2 === void 0 ? _MessageRepliesAvatars.MessageRepliesAvatars : _props$MessageReplies2,
    _props$MessageSimple = props.MessageSimple,
    MessageSimple = _props$MessageSimple === void 0 ? _MessageSimple.MessageSimple : _props$MessageSimple,
    _props$MessageStatus = props.MessageStatus,
    MessageStatus = _props$MessageStatus === void 0 ? _MessageStatus.MessageStatus : _props$MessageStatus,
    _props$MessageSwipeCo = props.MessageSwipeContent,
    MessageSwipeContent = _props$MessageSwipeCo === void 0 ? _MessageSwipeContent.MessageSwipeContent : _props$MessageSwipeCo,
    messageSwipeToReplyHitSlop = props.messageSwipeToReplyHitSlop,
    _props$MessageSystem = props.MessageSystem,
    MessageSystem = _props$MessageSystem === void 0 ? _MessageSystem.MessageSystem : _props$MessageSystem,
    MessageText = props.MessageText,
    messageTextNumberOfLines = props.messageTextNumberOfLines,
    _props$MessageTimesta = props.MessageTimestamp,
    MessageTimestamp = _props$MessageTimesta === void 0 ? _MessageTimestamp.MessageTimestamp : _props$MessageTimesta,
    _props$MessageUserRea = props.MessageUserReactions,
    MessageUserReactions = _props$MessageUserRea === void 0 ? _MessageUserReactions.MessageUserReactions : _props$MessageUserRea,
    _props$MessageUserRea2 = props.MessageUserReactionsAvatar,
    MessageUserReactionsAvatar = _props$MessageUserRea2 === void 0 ? _MessageUserReactionsAvatar.MessageUserReactionsAvatar : _props$MessageUserRea2,
    _props$MessageUserRea3 = props.MessageUserReactionsItem,
    MessageUserReactionsItem = _props$MessageUserRea3 === void 0 ? _MessageUserReactionsItem.MessageUserReactionsItem : _props$MessageUserRea3,
    _props$MoreOptionsBut = props.MoreOptionsButton,
    MoreOptionsButton = _props$MoreOptionsBut === void 0 ? _MoreOptionsButton.MoreOptionsButton : _props$MoreOptionsBut,
    myMessageTheme = props.myMessageTheme,
    _props$NetworkDownInd = props.NetworkDownIndicator,
    NetworkDownIndicator = _props$NetworkDownInd === void 0 ? _NetworkDownIndicator.NetworkDownIndicator : _props$NetworkDownInd,
    _props$newMessageStat = props.newMessageStateUpdateThrottleInterval,
    newMessageStateUpdateThrottleInterval = _props$newMessageStat === void 0 ? defaultThrottleInterval : _props$newMessageStat,
    onLongPressMessage = props.onLongPressMessage,
    onPressInMessage = props.onPressInMessage,
    onPressMessage = props.onPressMessage,
    openPollCreationDialog = props.openPollCreationDialog,
    overrideOwnCapabilities = props.overrideOwnCapabilities,
    PollContent = props.PollContent,
    _props$ReactionListBo = props.ReactionListBottom,
    ReactionListBottom = _props$ReactionListBo === void 0 ? _ReactionListBottom.ReactionListBottom : _props$ReactionListBo,
    _props$reactionListPo = props.reactionListPosition,
    reactionListPosition = _props$reactionListPo === void 0 ? 'top' : _props$reactionListPo,
    _props$ReactionListTo = props.ReactionListTop,
    ReactionListTop = _props$ReactionListTo === void 0 ? _ReactionListTop.ReactionListTop : _props$ReactionListTo,
    _props$Reply = props.Reply,
    Reply = _props$Reply === void 0 ? _Reply.Reply : _props$Reply,
    _props$ScrollToBottom = props.ScrollToBottomButton,
    ScrollToBottomButton = _props$ScrollToBottom === void 0 ? _ScrollToBottomButton.ScrollToBottomButton : _props$ScrollToBottom,
    selectReaction = props.selectReaction,
    _props$SendButton = props.SendButton,
    SendButton = _props$SendButton === void 0 ? _SendButton.SendButton : _props$SendButton,
    _props$SendMessageDis = props.SendMessageDisallowedIndicator,
    SendMessageDisallowedIndicator = _props$SendMessageDis === void 0 ? _SendMessageDisallowedIndicator.SendMessageDisallowedIndicator : _props$SendMessageDis,
    setInputRef = props.setInputRef,
    setThreadMessages = props.setThreadMessages,
    _props$shouldShowUnre = props.shouldShowUnreadUnderlay,
    shouldShowUnreadUnderlay = _props$shouldShowUnre === void 0 ? true : _props$shouldShowUnre,
    shouldSyncChannel = props.shouldSyncChannel,
    _props$ShowThreadMess = props.ShowThreadMessageInChannelButton,
    ShowThreadMessageInChannelButton = _props$ShowThreadMess === void 0 ? _ShowThreadMessageInChannelButton.ShowThreadMessageInChannelButton : _props$ShowThreadMess,
    _props$StartAudioReco = props.StartAudioRecordingButton,
    StartAudioRecordingButton = _props$StartAudioReco === void 0 ? _AudioRecordingButton.AudioRecordingButton : _props$StartAudioReco,
    _props$stateUpdateThr = props.stateUpdateThrottleInterval,
    stateUpdateThrottleInterval = _props$stateUpdateThr === void 0 ? defaultThrottleInterval : _props$stateUpdateThr,
    _props$StickyHeader = props.StickyHeader,
    StickyHeader = _props$StickyHeader === void 0 ? _StickyHeader.StickyHeader : _props$StickyHeader,
    StopMessageStreamingButtonOverride = props.StopMessageStreamingButton,
    _props$StreamingMessa = props.StreamingMessageView,
    StreamingMessageView = _props$StreamingMessa === void 0 ? _StreamingMessageView.StreamingMessageView : _props$StreamingMessa,
    _props$supportedReact = props.supportedReactions,
    supportedReactions = _props$supportedReact === void 0 ? reactionData : _props$supportedReact,
    t = props.t,
    threadFromProps = props.thread,
    threadList = props.threadList,
    threadMessages = props.threadMessages,
    topInset = props.topInset,
    _props$TypingIndicato = props.TypingIndicator,
    TypingIndicator = _props$TypingIndicato === void 0 ? _TypingIndicator.TypingIndicator : _props$TypingIndicato,
    _props$TypingIndicato2 = props.TypingIndicatorContainer,
    TypingIndicatorContainer = _props$TypingIndicato2 === void 0 ? _TypingIndicatorContainer.TypingIndicatorContainer : _props$TypingIndicato2,
    _props$UnreadMessages = props.UnreadMessagesNotification,
    UnreadMessagesNotification = _props$UnreadMessages === void 0 ? _UnreadMessagesNotification.UnreadMessagesNotification : _props$UnreadMessages,
    _props$AttachmentUplo2 = props.AttachmentUploadProgressIndicator,
    AttachmentUploadProgressIndicator = _props$AttachmentUplo2 === void 0 ? _AttachmentUploadProgressIndicator.AttachmentUploadProgressIndicator : _props$AttachmentUplo2,
    _props$UrlPreview = props.UrlPreview,
    UrlPreview = _props$UrlPreview === void 0 ? _Card.Card : _props$UrlPreview,
    _props$VideoAttachmen = props.VideoAttachmentUploadPreview,
    VideoAttachmentUploadPreview = _props$VideoAttachmen === void 0 ? _FileAttachmentUploadPreview.FileAttachmentUploadPreview : _props$VideoAttachmen,
    _props$VideoThumbnail = props.VideoThumbnail,
    VideoThumbnail = _props$VideoThumbnail === void 0 ? _VideoThumbnail.VideoThumbnail : _props$VideoThumbnail,
    isOnline = props.isOnline;
  var threadProps = threadFromProps.thread,
    threadInstance = threadFromProps.threadInstance;
  var StopMessageStreamingButton = StopMessageStreamingButtonOverride === undefined ? _StopMessageStreamingButton.StopMessageStreamingButton : StopMessageStreamingButtonOverride;
  var _useTheme = (0, _ThemeContext.useTheme)(),
    _useTheme$theme = _useTheme.theme,
    selectChannel = _useTheme$theme.channel.selectChannel,
    black = _useTheme$theme.colors.black;
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    deleted = _useState2[0],
    setDeleted = _useState2[1];
  var _useState3 = (0, _react.useState)(false),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    error = _useState4[0],
    setError = _useState4[1];
  var _useState5 = (0, _react.useState)(),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    lastRead = _useState6[0],
    setLastRead = _useState6[1];
  var _useState7 = (0, _react.useState)(threadProps || null),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    thread = _useState8[0],
    setThread = _useState8[1];
  var _useState9 = (0, _react.useState)(true),
    _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
    threadHasMore = _useState10[0],
    setThreadHasMore = _useState10[1];
  var _useState11 = (0, _react.useState)(false),
    _useState12 = (0, _slicedToArray2.default)(_useState11, 2),
    threadLoadingMore = _useState12[0],
    setThreadLoadingMore = _useState12[1];
  var _useState13 = (0, _react.useState)(undefined),
    _useState14 = (0, _slicedToArray2.default)(_useState13, 2),
    channelUnreadState = _useState14[0],
    setChannelUnreadState = _useState14[1];
  var _useAttachmentPickerB = (0, _useAttachmentPickerBottomSheet.useAttachmentPickerBottomSheet)(),
    bottomSheetRef = _useAttachmentPickerB.bottomSheetRef,
    _closePicker = _useAttachmentPickerB.closePicker,
    _openPicker = _useAttachmentPickerB.openPicker;
  var syncingChannelRef = (0, _react.useRef)(false);
  var _useTargetedMessage = (0, _useTargetedMessage2.useTargetedMessage)(),
    highlightedMessageId = _useTargetedMessage.highlightedMessageId,
    setTargetedMessage = _useTargetedMessage.setTargetedMessage,
    targetedMessage = _useTargetedMessage.targetedMessage;
  var uploadAbortControllerRef = (0, _react.useRef)(new Map());
  var optimisticallyUpdatedNewMessages = (0, _react.useMemo)(function () {
    return new Set();
  }, []);
  var channelId = (channel == null ? void 0 : channel.id) || '';
  var pollCreationEnabled = !channel.disconnected && !!(channel != null && channel.id) && (channel == null || (_channel$getConfig = channel.getConfig()) == null ? void 0 : _channel$getConfig.polls);
  var _useChannelDataState = (0, _useChannelDataState2.useChannelDataState)(channel),
    copyStateFromChannel = _useChannelDataState.copyStateFromChannel,
    initStateFromChannel = _useChannelDataState.initStateFromChannel,
    setRead = _useChannelDataState.setRead,
    setTyping = _useChannelDataState.setTyping,
    channelState = _useChannelDataState.state;
  var _useMessageListPagina = (0, _useMessageListPagination.useMessageListPagination)({
      channel: channel
    }),
    copyMessagesStateFromChannel = _useMessageListPagina.copyMessagesStateFromChannel,
    loadChannelAroundMessageFn = _useMessageListPagina.loadChannelAroundMessage,
    loadChannelAtFirstUnreadMessage = _useMessageListPagina.loadChannelAtFirstUnreadMessage,
    loadInitialMessagesStateFromChannel = _useMessageListPagina.loadInitialMessagesStateFromChannel,
    loadLatestMessages = _useMessageListPagina.loadLatestMessages,
    loadMore = _useMessageListPagina.loadMore,
    loadMoreRecent = _useMessageListPagina.loadMoreRecent,
    channelMessagesState = _useMessageListPagina.state;
  var setReadThrottled = (0, _react.useMemo)(function () {
    return (0, _throttle.default)(function () {
      if (channel) {
        setRead(channel);
      }
    }, stateUpdateThrottleInterval, throttleOptions);
  }, [channel, stateUpdateThrottleInterval, setRead]);
  var copyMessagesStateFromChannelThrottled = (0, _react.useMemo)(function () {
    return (0, _throttle.default)(function () {
      if (channel) {
        copyMessagesStateFromChannel(channel);
      }
    }, newMessageStateUpdateThrottleInterval, throttleOptions);
  }, [channel, newMessageStateUpdateThrottleInterval, copyMessagesStateFromChannel]);
  var copyChannelState = (0, _react.useMemo)(function () {
    return (0, _throttle.default)(function () {
      if (channel) {
        copyStateFromChannel(channel);
        copyMessagesStateFromChannel(channel);
      }
    }, stateUpdateThrottleInterval, throttleOptions);
  }, [stateUpdateThrottleInterval, channel, copyStateFromChannel, copyMessagesStateFromChannel]);
  var handleEvent = (0, _hooks.useStableCallback)(function (event) {
    if (shouldSyncChannel) {
      if (event.type.startsWith('poll.') || event.type === 'user.watching.start' || event.type === 'user.watching.stop') {
        return;
      }
      if (event.type === 'typing.start' || event.type === 'typing.stop') {
        var _event$user;
        if (((_event$user = event.user) == null ? void 0 : _event$user.id) !== client.userID) {
          setTyping(channel);
        }
        return;
      } else {
        if (thread != null && thread.id) {
          var _event$message;
          var updatedThreadMessages = thread.id && channel && channel.state.threads[thread.id] || threadMessages;
          setThreadMessages(updatedThreadMessages);
          if (channel && ((_event$message = event.message) == null ? void 0 : _event$message.id) === thread.id && !threadInstance) {
            var updatedThread = channel.state.formatMessage(event.message);
            setThread(updatedThread);
          }
        }
      }
      if (event.type === 'notification.mark_unread') {
        setChannelUnreadState(function (prev) {
          var _event$unread_message;
          if (!(event.last_read_at && event.user)) {
            return prev;
          }
          return {
            first_unread_message_id: event.first_unread_message_id,
            last_read: new Date(event.last_read_at),
            last_read_message_id: event.last_read_message_id,
            unread_messages: (_event$unread_message = event.unread_messages) != null ? _event$unread_message : 0
          };
        });
      }
      if (event.type === 'channel.truncated' && event.cid === channel.cid) {
        setChannelUnreadState(undefined);
      }
      if (channel && channel.initialized) {
        if (event.type === 'message.new' || event.type === 'notification.message_new') {
          var _event$message$id, _event$message2, _event$user2;
          var _messageId = (_event$message$id = (_event$message2 = event.message) == null ? void 0 : _event$message2.id) != null ? _event$message$id : '';
          if (((_event$user2 = event.user) == null ? void 0 : _event$user2.id) !== client.userID || !optimisticallyUpdatedNewMessages.has(_messageId)) {
            copyMessagesStateFromChannelThrottled();
          }
          optimisticallyUpdatedNewMessages.delete(_messageId);
          return;
        }
        if (event.type === 'message.read' || event.type === 'notification.mark_read') {
          setReadThrottled();
          return;
        }
        copyChannelState();
      }
    }
  });
  (0, _react.useEffect)(function () {
    var listener;
    var initChannel = function () {
      var _ref = (0, _asyncToGenerator2.default)(function* () {
        var _client$user;
        setLastRead(new Date());
        var unreadCount = channel.countUnread();
        if (!channel || !shouldSyncChannel) {
          return;
        }
        var errored = false;
        if (!channel.initialized || !channel.state.isUpToDate) {
          try {
            yield channel == null ? void 0 : channel.watch();
          } catch (err) {
            console.warn('Channel watch request failed with error:', err);
            setError(true);
            errored = true;
          }
        }
        if (!errored) {
          initStateFromChannel(channel);
          loadInitialMessagesStateFromChannel(channel, channel.state.messagePagination.hasPrev);
        }
        if ((_client$user = client.user) != null && _client$user.id && channel.state.read[client.user.id]) {
          var _channel$state$read$c = channel.state.read[client.user.id],
            user = _channel$state$read$c.user,
            ownReadState = (0, _objectWithoutProperties2.default)(_channel$state$read$c, _excluded);
          setChannelUnreadState(ownReadState);
        }
        if (messageId) {
          yield loadChannelAroundMessage({
            messageId: messageId,
            setTargetedMessage: setTargetedMessage
          });
        } else if (initialScrollToFirstUnreadMessage && client.user && unreadCount > scrollToFirstUnreadThreshold) {
          var _channel$state$read$c2 = channel.state.read[client.user.id],
            _user = _channel$state$read$c2.user,
            _ownReadState = (0, _objectWithoutProperties2.default)(_channel$state$read$c2, _excluded2);
          yield loadChannelAtFirstUnreadMessage({
            channelUnreadState: _ownReadState,
            setChannelUnreadState: setChannelUnreadState,
            setTargetedMessage: setTargetedMessage
          });
        }
        if (unreadCount > 0 && markReadOnMount) {
          yield markRead({
            updateChannelUnreadState: false
          });
        }
        listener = channel.on(handleEvent);
      });
      return function initChannel() {
        return _ref.apply(this, arguments);
      };
    }();
    initChannel();
    return function () {
      var _listener;
      copyChannelState.cancel();
      loadMoreThreadFinished.cancel();
      (_listener = listener) == null || _listener.unsubscribe();
    };
  }, [channel.cid, messageId, shouldSyncChannel]);
  (0, _react.useEffect)(function () {
    var _client$on = client.on('channel.deleted', function (event) {
        if (event.cid === (channel == null ? void 0 : channel.cid)) {
          setDeleted(true);
        }
      }),
      unsubscribe = _client$on.unsubscribe;
    return unsubscribe;
  }, [channel == null ? void 0 : channel.cid, client]);
  var threadPropsExists = !!threadProps;
  (0, _react.useEffect)(function () {
    if (threadProps && shouldSyncChannel) {
      setThread(threadProps);
      if (channel && threadProps != null && threadProps.id) {
        var _channel$state$thread;
        setThreadMessages(((_channel$state$thread = channel.state.threads) == null ? void 0 : _channel$state$thread[threadProps.id]) || []);
      }
    } else {
      setThread(null);
    }
  }, [threadPropsExists, shouldSyncChannel]);
  var handleAppBackground = (0, _react.useCallback)(function () {
    var _channelData$own_capa;
    var channelData = channel.data;
    if (channelData != null && (_channelData$own_capa = channelData.own_capabilities) != null && _channelData$own_capa.includes('send-typing-events')) {
      channel.sendEvent({
        parent_id: thread == null ? void 0 : thread.id,
        type: 'typing.stop'
      });
    }
  }, [thread == null ? void 0 : thread.id, channelId]);
  (0, _useAppStateListener.useAppStateListener)(undefined, handleAppBackground);
  var markReadInternal = (0, _throttle.default)(function () {
    var _ref2 = (0, _asyncToGenerator2.default)(function* (options) {
      var _ref3 = options != null ? options : {},
        _ref3$updateChannelUn = _ref3.updateChannelUnreadState,
        updateChannelUnreadState = _ref3$updateChannelUn === void 0 ? true : _ref3$updateChannelUn;
      if (!channel || channel != null && channel.disconnected || !(clientChannelConfig != null && clientChannelConfig.read_events)) {
        return;
      }
      if (doMarkReadRequest) {
        doMarkReadRequest(channel, updateChannelUnreadState ? setChannelUnreadState : undefined);
      } else {
        try {
          var response = yield channel.markRead();
          if (updateChannelUnreadState && response && lastRead) {
            setChannelUnreadState({
              last_read: lastRead,
              last_read_message_id: response == null ? void 0 : response.event.last_read_message_id,
              unread_messages: 0
            });
            setLastRead(new Date());
          }
        } catch (err) {
          console.log('Error marking channel as read:', err);
        }
      }
    });
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), defaultThrottleInterval, throttleOptions);
  var markRead = (0, _hooks.useStableCallback)(markReadInternal);
  var reloadThread = (0, _hooks.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    if (!channel || !(thread != null && thread.id)) {
      return;
    }
    setThreadLoadingMore(true);
    try {
      var parentID = thread.id;
      var limit = 50;
      channel.state.threads[parentID] = [];
      var queryResponse = yield channel.getReplies(parentID, {
        limit: limit
      });
      var updatedHasMore = queryResponse.messages.length === limit;
      var updatedThreadMessages = channel.state.threads[parentID] || [];
      loadMoreThreadFinished(updatedHasMore, updatedThreadMessages);
      var _yield$channel$getMes = yield channel.getMessagesById([parentID]),
        messages = _yield$channel$getMes.messages;
      var _messages = (0, _slicedToArray2.default)(messages, 1),
        threadMessage = _messages[0];
      if (threadMessage && !threadInstance) {
        var formattedMessage = channel.state.formatMessage(threadMessage);
        setThread(formattedMessage);
      }
    } catch (err) {
      console.warn('Thread loading request failed with error', err);
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(true);
      }
      setThreadLoadingMore(false);
      throw err;
    }
  }));
  var resyncChannel = (0, _hooks.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    if (!channel || syncingChannelRef.current) {
      return;
    }
    syncingChannelRef.current = true;
    setError(false);
    var parseMessage = function parseMessage(message) {
      var _message$pinned_at, _message$updated_at;
      return Object.assign({}, message, {
        created_at: message.created_at.toString(),
        pinned_at: (_message$pinned_at = message.pinned_at) == null ? void 0 : _message$pinned_at.toString(),
        updated_at: (_message$updated_at = message.updated_at) == null ? void 0 : _message$updated_at.toString()
      });
    };
    try {
      if (channelMessagesState != null && channelMessagesState.messages) {
        yield channel == null ? void 0 : channel.watch({
          messages: {
            limit: channelMessagesState.messages.length + 30
          }
        });
      }
      if (!thread) {
        var _channelMessagesState;
        copyChannelState();
        var failedMessages = (_channelMessagesState = channelMessagesState.messages) == null ? void 0 : _channelMessagesState.filter(function (message) {
          return message.status === _utils.MessageStatusTypes.FAILED;
        }).map(parseMessage);
        if (failedMessages != null && failedMessages.length) {
          channel.state.addMessagesSorted(failedMessages);
        }
        yield markRead();
        channel.state.setIsUpToDate(true);
      } else {
        yield reloadThread();
        var failedThreadMessages = thread ? threadMessages.filter(function (message) {
          return message.status === _utils.MessageStatusTypes.FAILED;
        }).map(parseMessage) : [];
        if (failedThreadMessages.length) {
          channel.state.addMessagesSorted(failedThreadMessages);
          setThreadMessages((0, _toConsumableArray2.default)(channel.state.threads[thread.id]));
        }
      }
    } catch (err) {
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(true);
      }
    }
    syncingChannelRef.current = false;
  }));
  var resyncChannelRef = (0, _react.useRef)(resyncChannel);
  resyncChannelRef.current = resyncChannel;
  (0, _react.useEffect)(function () {
    var connectionChangedHandler = function connectionChangedHandler() {
      if (shouldSyncChannel) {
        resyncChannelRef.current();
      }
    };
    var connectionChangedSubscription;
    if (enableOfflineSupport && client.offlineDb) {
      connectionChangedSubscription = client.offlineDb.syncManager.onSyncStatusChange(function (statusChanged) {
        if (statusChanged) {
          connectionChangedHandler();
        }
      });
    } else {
      connectionChangedSubscription = client.on('connection.changed', function (event) {
        if (event.online) {
          connectionChangedHandler();
        }
      });
    }
    return function () {
      connectionChangedSubscription.unsubscribe();
    };
  }, [enableOfflineSupport, client, shouldSyncChannel]);
  var getChannelConfigSafely = function getChannelConfigSafely() {
    try {
      return channel == null ? void 0 : channel.getConfig();
    } catch (_) {
      return null;
    }
  };
  var clientChannelConfig = getChannelConfigSafely();
  var reloadChannel = (0, _hooks.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    try {
      yield loadLatestMessages();
    } catch (err) {
      console.warn('Reloading channel failed with error:', err);
    }
  }));
  var loadChannelAroundMessage = (0, _hooks.useStableCallback)(function () {
    var _ref8 = (0, _asyncToGenerator2.default)(function* (_ref7) {
      var messageIdToLoadAround = _ref7.messageId;
      if (!messageIdToLoadAround) {
        return;
      }
      try {
        if (thread) {
          setThreadLoadingMore(true);
          try {
            yield channel.state.loadMessageIntoState(messageIdToLoadAround, thread.id);
            setThreadLoadingMore(false);
            setThreadMessages(channel.state.threads[thread.id]);
            if (setTargetedMessage) {
              setTargetedMessage(messageIdToLoadAround);
            }
          } catch (err) {
            if (err instanceof Error) {
              setError(err);
            } else {
              setError(true);
            }
            setThreadLoadingMore(false);
          }
        } else {
          yield loadChannelAroundMessageFn({
            messageId: messageIdToLoadAround,
            setTargetedMessage: setTargetedMessage
          });
        }
      } catch (err) {
        console.warn('Loading channel around message failed with error:', err);
      }
    });
    return function (_x2) {
      return _ref8.apply(this, arguments);
    };
  }());
  var updateMessage = (0, _hooks.useStableCallback)(function (updatedMessage) {
    var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var throttled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (!channel) {
      return;
    }
    channel.state.addMessageSorted(updatedMessage, true);
    if (throttled) {
      copyMessagesStateFromChannelThrottled();
    } else {
      copyMessagesStateFromChannel(channel);
    }
    if (thread && updatedMessage.parent_id) {
      extraState.threadMessages = channel.state.threads[updatedMessage.parent_id] || [];
      setThreadMessages(extraState.threadMessages);
    }
  });
  var replaceMessage = (0, _hooks.useStableCallback)(function (oldMessage, newMessage) {
    if (channel) {
      channel.state.removeMessage(oldMessage);
      channel.state.addMessageSorted(newMessage, true);
      copyMessagesStateFromChannel(channel);
      if (thread && newMessage.parent_id) {
        var _threadMessages = channel.state.threads[newMessage.parent_id] || [];
        setThreadMessages(_threadMessages);
      }
    }
  });
  var uploadPendingAttachments = (0, _hooks.useStableCallback)(function () {
    var _ref9 = (0, _asyncToGenerator2.default)(function* (message) {
      var _updatedMessage$attac;
      var updatedMessage = Object.assign({}, message);
      if ((_updatedMessage$attac = updatedMessage.attachments) != null && _updatedMessage$attac.length) {
        for (var i = 0; i < ((_updatedMessage$attac2 = updatedMessage.attachments) == null ? void 0 : _updatedMessage$attac2.length); i++) {
          var _updatedMessage$attac2;
          var attachment = updatedMessage.attachments[i];
          if (attachment.image_url && !(0, _utils.isLocalUrl)(attachment.image_url) || attachment.asset_url && !(0, _utils.isLocalUrl)(attachment.asset_url)) {
            continue;
          }
          var image = attachment.originalFile;
          var file = attachment.originalFile;
          if (attachment.type === _types.FileTypes.Image && image != null && image.uri) {
            var _image$name;
            var filename = (_image$name = image.name) != null ? _image$name : (0, _utils.getFileNameFromPath)(image.uri);
            var controller = uploadAbortControllerRef.current.get(filename);
            if (controller) {
              controller.abort();
              uploadAbortControllerRef.current.delete(filename);
            }
            var compressedUri = yield (0, _compressImage.compressedImageURI)(image, compressImageQuality);
            var contentType = (0, _mimeTypes.lookup)(filename) || 'multipart/form-data';
            var uploadResponse = doFileUploadRequest ? yield doFileUploadRequest(image) : yield channel.sendImage(compressedUri, filename, contentType);
            attachment.image_url = uploadResponse.file;
            delete attachment.originalFile;
            yield dbApi.updateMessage({
              message: Object.assign({}, updatedMessage, {
                cid: channel.cid
              })
            });
          }
          if (attachment.type !== _types.FileTypes.Image && file != null && file.uri) {
            var _controller = uploadAbortControllerRef.current.get(file.name);
            if (_controller) {
              _controller.abort();
              uploadAbortControllerRef.current.delete(file.name);
            }
            var response = doFileUploadRequest ? yield doFileUploadRequest(file) : yield channel.sendFile(file.uri, file.name, file.type);
            attachment.asset_url = response.file;
            if (response.thumb_url) {
              attachment.thumb_url = response.thumb_url;
            }
            delete attachment.originalFile;
            yield dbApi.updateMessage({
              message: Object.assign({}, updatedMessage, {
                cid: channel.cid
              })
            });
          }
        }
      }
      return updatedMessage;
    });
    return function (_x3) {
      return _ref9.apply(this, arguments);
    };
  }());
  var sendMessageRequest = (0, _hooks.useStableCallback)(function () {
    var _ref11 = (0, _asyncToGenerator2.default)(function* (_ref10) {
      var localMessage = _ref10.localMessage,
        message = _ref10.message,
        options = _ref10.options,
        retrying = _ref10.retrying;
      var failedMessageUpdated = false;
      var handleFailedMessage = function () {
        var _ref12 = (0, _asyncToGenerator2.default)(function* () {
          if (!failedMessageUpdated) {
            var updatedMessage = Object.assign({}, localMessage, {
              cid: channel.cid,
              status: _utils.MessageStatusTypes.FAILED
            });
            updateMessage(updatedMessage);
            threadInstance == null || threadInstance.upsertReplyLocally == null || threadInstance.upsertReplyLocally({
              message: updatedMessage
            });
            optimisticallyUpdatedNewMessages.delete(localMessage.id);
            if (enableOfflineSupport) {
              yield dbApi.updateMessage({
                message: updatedMessage
              });
            }
            failedMessageUpdated = true;
          }
        });
        return function handleFailedMessage() {
          return _ref12.apply(this, arguments);
        };
      }();
      try {
        var _messageResponse;
        if (!isOnline) {
          yield handleFailedMessage();
        }
        var updatedLocalMessage = yield uploadPendingAttachments(localMessage);
        var attachments = updatedLocalMessage.attachments;
        var text = message.text,
          mentioned_users = message.mentioned_users;
        if (!channel.id) {
          return;
        }
        var messageData = Object.assign({}, message, {
          attachments: attachments,
          text: (0, _patchMessageTextCommand.patchMessageTextCommand)(text != null ? text : '', mentioned_users != null ? mentioned_users : [])
        });
        var messageResponse = {};
        if (doSendMessageRequest) {
          messageResponse = yield doSendMessageRequest((channel == null ? void 0 : channel.cid) || '', messageData, options);
        } else if (channel) {
          messageResponse = yield channel.sendMessage(messageData, options);
        }
        if ((_messageResponse = messageResponse) != null && _messageResponse.message) {
          var newMessageResponse = Object.assign({}, messageResponse.message, {
            status: _utils.MessageStatusTypes.RECEIVED
          });
          if (enableOfflineSupport) {
            yield dbApi.updateMessage({
              message: Object.assign({}, newMessageResponse, {
                cid: channel.cid
              })
            });
          }
          if (retrying) {
            replaceMessage(localMessage, newMessageResponse);
          } else {
            updateMessage(newMessageResponse, {}, true);
          }
        }
      } catch (err) {
        console.log('Error sending message:', err);
        yield handleFailedMessage();
      }
    });
    return function (_x4) {
      return _ref11.apply(this, arguments);
    };
  }());
  var sendMessage = (0, _hooks.useStableCallback)(function () {
    var _ref14 = (0, _asyncToGenerator2.default)(function* (_ref13) {
      var _channel$state;
      var localMessage = _ref13.localMessage,
        message = _ref13.message,
        options = _ref13.options;
      if (channel != null && (_channel$state = channel.state) != null && _channel$state.filterErrorMessages) {
        channel.state.filterErrorMessages();
      }
      updateMessage(localMessage);
      threadInstance == null || threadInstance.upsertReplyLocally == null || threadInstance.upsertReplyLocally({
        message: localMessage
      });
      optimisticallyUpdatedNewMessages.add(localMessage.id);
      if (enableOfflineSupport) {
        yield dbApi.upsertMessages({
          messages: [Object.assign({}, localMessage, {
            cid: channel.cid,
            status: _utils.MessageStatusTypes.FAILED
          })]
        });
      }
      yield sendMessageRequest({
        localMessage: localMessage,
        message: message,
        options: options
      });
    });
    return function (_x5) {
      return _ref14.apply(this, arguments);
    };
  }());
  var retrySendMessage = (0, _hooks.useStableCallback)(function () {
    var _ref15 = (0, _asyncToGenerator2.default)(function* (localMessage) {
      var statusPendingMessage = Object.assign({}, localMessage, {
        status: _utils.MessageStatusTypes.SENDING
      });
      var messageWithoutReservedFields = (0, _streamChat.localMessageToNewMessagePayload)(statusPendingMessage);
      if (!(0, _utils.isBouncedMessage)(localMessage)) {
        updateMessage(messageWithoutReservedFields);
      }
      yield sendMessageRequest({
        localMessage: localMessage,
        message: messageWithoutReservedFields,
        retrying: true
      });
    });
    return function (_x6) {
      return _ref15.apply(this, arguments);
    };
  }());
  var editMessage = (0, _hooks.useStableCallback)(function (_ref16) {
    var localMessage = _ref16.localMessage,
      options = _ref16.options;
    return doUpdateMessageRequest ? doUpdateMessageRequest((channel == null ? void 0 : channel.cid) || '', localMessage, options) : client.updateMessage(localMessage, undefined, options);
  });
  var removeMessage = (0, _hooks.useStableCallback)(function () {
    var _ref17 = (0, _asyncToGenerator2.default)(function* (message) {
      if (channel) {
        channel.state.removeMessage(message);
        copyMessagesStateFromChannel(channel);
        if (thread) {
          setThreadMessages(channel.state.threads[thread.id] || []);
        }
      }
      if (client.offlineDb) {
        yield client.offlineDb.handleRemoveMessage({
          messageId: message.id
        });
      }
    });
    return function (_x7) {
      return _ref17.apply(this, arguments);
    };
  }());
  var sendReaction = (0, _hooks.useStableCallback)(function () {
    var _ref18 = (0, _asyncToGenerator2.default)(function* (type, messageId) {
      if (!(channel != null && channel.id) || !client.user) {
        throw new Error('Channel has not been initialized');
      }
      var payload = [messageId, {
        type: type
      }, {
        enforce_unique: enforceUniqueReaction
      }];
      if (enableOfflineSupport) {
        yield (0, _addReactionToLocalState.addReactionToLocalState)({
          channel: channel,
          enforceUniqueReaction: enforceUniqueReaction,
          messageId: messageId,
          reactionType: type,
          user: client.user
        });
        copyMessagesStateFromChannel(channel);
      }
      var sendReactionResponse = yield channel.sendReaction.apply(channel, payload);
      if (sendReactionResponse != null && sendReactionResponse.message) {
        threadInstance == null || threadInstance.upsertReplyLocally == null || threadInstance.upsertReplyLocally({
          message: sendReactionResponse.message
        });
      }
    });
    return function (_x8, _x9) {
      return _ref18.apply(this, arguments);
    };
  }());
  var deleteMessage = (0, _hooks.useStableCallback)(function () {
    var _ref19 = (0, _asyncToGenerator2.default)(function* (message) {
      var hardDelete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!channel.id) {
        throw new Error('Channel has not been initialized yet');
      }
      if (message.status === _utils.MessageStatusTypes.FAILED) {
        yield removeMessage(message);
        return;
      }
      var updatedMessage = Object.assign({}, message, {
        cid: channel.cid,
        deleted_at: new Date(),
        type: 'deleted'
      });
      updateMessage(updatedMessage);
      threadInstance == null || threadInstance.upsertReplyLocally({
        message: updatedMessage
      });
      var data = yield client.deleteMessage(message.id, hardDelete);
      if (data != null && data.message) {
        updateMessage(Object.assign({}, data.message));
      }
    });
    return function (_x10) {
      return _ref19.apply(this, arguments);
    };
  }());
  var deleteReaction = (0, _hooks.useStableCallback)(function () {
    var _ref20 = (0, _asyncToGenerator2.default)(function* (type, messageId) {
      if (!(channel != null && channel.id) || !client.user) {
        throw new Error('Channel has not been initialized');
      }
      var payload = [messageId, type];
      if (enableOfflineSupport) {
        channel.state.removeReaction({
          created_at: '',
          message_id: messageId,
          type: type,
          updated_at: ''
        });
        copyMessagesStateFromChannel(channel);
      }
      yield channel.deleteReaction.apply(channel, payload);
    });
    return function (_x11, _x12) {
      return _ref20.apply(this, arguments);
    };
  }());
  var openThread = (0, _react.useCallback)(function (message) {
    setThread(message);
    if (channel.initialized) {
      channel.markRead({
        thread_id: message.id
      });
    }
  }, [channel, setThread]);
  var closeThread = (0, _react.useCallback)(function () {
    setThread(null);
    setThreadMessages([]);
  }, [setThread, setThreadMessages]);
  var loadMoreThreadFinished = (0, _react.useRef)((0, _debounce.default)(function (newThreadHasMore, updatedThreadMessages) {
    setThreadHasMore(newThreadHasMore);
    setThreadLoadingMore(false);
    setThreadMessages(updatedThreadMessages);
  }, defaultDebounceInterval, debounceOptions)).current;
  var loadMoreThread = (0, _hooks.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    if (threadLoadingMore || !(thread != null && thread.id)) {
      return;
    }
    setThreadLoadingMore(true);
    try {
      if (channel) {
        var _threadMessages$;
        var parentID = thread.id;
        channel.state.threads[parentID] = threadMessages;
        var oldestMessageID = threadMessages == null || (_threadMessages$ = threadMessages[0]) == null ? void 0 : _threadMessages$.id;
        var limit = 50;
        var queryResponse = yield channel.getReplies(parentID, {
          id_lt: oldestMessageID,
          limit: limit
        });
        var updatedHasMore = queryResponse.messages.length === limit;
        var updatedThreadMessages = channel.state.threads[parentID] || [];
        loadMoreThreadFinished(updatedHasMore, updatedThreadMessages);
      }
    } catch (err) {
      console.warn('Message pagination request failed with error', err);
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(true);
      }
      setThreadLoadingMore(false);
      throw err;
    }
  }));
  var attachmentPickerProps = (0, _react.useMemo)(function () {
    return {
      AttachmentPickerBottomSheetHandle: AttachmentPickerBottomSheetHandle,
      attachmentPickerBottomSheetHandleHeight: attachmentPickerBottomSheetHandleHeight,
      attachmentPickerBottomSheetHeight: attachmentPickerBottomSheetHeight,
      AttachmentPickerError: AttachmentPickerError,
      attachmentPickerErrorButtonText: attachmentPickerErrorButtonText,
      AttachmentPickerErrorImage: AttachmentPickerErrorImage,
      attachmentPickerErrorText: attachmentPickerErrorText,
      AttachmentPickerIOSSelectMorePhotos: AttachmentPickerIOSSelectMorePhotos,
      attachmentSelectionBarHeight: attachmentSelectionBarHeight,
      ImageOverlaySelectedComponent: ImageOverlaySelectedComponent,
      numberOfAttachmentImagesToLoadPerCall: numberOfAttachmentImagesToLoadPerCall,
      numberOfAttachmentPickerImageColumns: numberOfAttachmentPickerImageColumns
    };
  }, [AttachmentPickerBottomSheetHandle, attachmentPickerBottomSheetHandleHeight, attachmentPickerBottomSheetHeight, AttachmentPickerError, attachmentPickerErrorButtonText, AttachmentPickerErrorImage, attachmentPickerErrorText, AttachmentPickerIOSSelectMorePhotos, attachmentSelectionBarHeight, ImageOverlaySelectedComponent, numberOfAttachmentImagesToLoadPerCall, numberOfAttachmentPickerImageColumns]);
  var attachmentPickerContext = (0, _react.useMemo)(function () {
    return {
      bottomInset: bottomInset,
      bottomSheetRef: bottomSheetRef,
      closePicker: function closePicker() {
        return _closePicker(bottomSheetRef);
      },
      openPicker: function openPicker() {
        return _openPicker(bottomSheetRef);
      },
      topInset: topInset
    };
  }, [bottomInset, bottomSheetRef, _closePicker, _openPicker, topInset]);
  var ownCapabilitiesContext = (0, _useCreateOwnCapabilitiesContext.useCreateOwnCapabilitiesContext)({
    channel: channel,
    overrideCapabilities: overrideOwnCapabilities
  });
  var channelContext = (0, _useCreateChannelContext.useCreateChannelContext)({
    channel: channel,
    channelUnreadState: channelUnreadState,
    disabled: !!(channel != null && (_channel$data = channel.data) != null && _channel$data.frozen),
    EmptyStateIndicator: EmptyStateIndicator,
    enableMessageGroupingByUser: enableMessageGroupingByUser,
    enforceUniqueReaction: enforceUniqueReaction,
    error: error,
    hideDateSeparators: hideDateSeparators,
    hideStickyDateHeader: hideStickyDateHeader,
    highlightedMessageId: highlightedMessageId,
    isChannelActive: shouldSyncChannel,
    lastRead: lastRead,
    loadChannelAroundMessage: loadChannelAroundMessage,
    loadChannelAtFirstUnreadMessage: loadChannelAtFirstUnreadMessage,
    loading: channelMessagesState.loading,
    LoadingIndicator: LoadingIndicator,
    markRead: markRead,
    maxTimeBetweenGroupedMessages: maxTimeBetweenGroupedMessages,
    members: (_channelState$members = channelState.members) != null ? _channelState$members : {},
    NetworkDownIndicator: NetworkDownIndicator,
    read: (_channelState$read = channelState.read) != null ? _channelState$read : {},
    reloadChannel: reloadChannel,
    scrollToFirstUnreadThreshold: scrollToFirstUnreadThreshold,
    setChannelUnreadState: setChannelUnreadState,
    setLastRead: setLastRead,
    setTargetedMessage: setTargetedMessage,
    StickyHeader: StickyHeader,
    targetedMessage: targetedMessage,
    threadList: threadList,
    uploadAbortControllerRef: uploadAbortControllerRef,
    watcherCount: channelState.watcherCount,
    watchers: channelState.watchers
  });
  var inputMessageInputContext = (0, _useCreateInputMessageInputContext.useCreateInputMessageInputContext)({
    additionalTextInputProps: additionalTextInputProps,
    asyncMessagesLockDistance: asyncMessagesLockDistance,
    asyncMessagesMinimumPressDuration: asyncMessagesMinimumPressDuration,
    asyncMessagesMultiSendEnabled: asyncMessagesMultiSendEnabled,
    asyncMessagesSlideToCancelDistance: asyncMessagesSlideToCancelDistance,
    AttachButton: AttachButton,
    AttachmentPickerBottomSheetHandle: AttachmentPickerBottomSheetHandle,
    attachmentPickerBottomSheetHandleHeight: attachmentPickerBottomSheetHandleHeight,
    attachmentPickerBottomSheetHeight: attachmentPickerBottomSheetHeight,
    AttachmentPickerSelectionBar: AttachmentPickerSelectionBar,
    attachmentSelectionBarHeight: attachmentSelectionBarHeight,
    AttachmentUploadPreviewList: AttachmentUploadPreviewList,
    AttachmentUploadProgressIndicator: AttachmentUploadProgressIndicator,
    AudioAttachmentUploadPreview: AudioAttachmentUploadPreview,
    AudioRecorder: AudioRecorder,
    audioRecordingEnabled: audioRecordingEnabled,
    AudioRecordingInProgress: AudioRecordingInProgress,
    AudioRecordingLockIndicator: AudioRecordingLockIndicator,
    AudioRecordingPreview: AudioRecordingPreview,
    AudioRecordingWaveform: AudioRecordingWaveform,
    AutoCompleteSuggestionHeader: AutoCompleteSuggestionHeader,
    AutoCompleteSuggestionItem: AutoCompleteSuggestionItem,
    AutoCompleteSuggestionList: AutoCompleteSuggestionList,
    CameraSelectorIcon: CameraSelectorIcon,
    channelId: channelId,
    CommandInput: CommandInput,
    CommandsButton: CommandsButton,
    compressImageQuality: compressImageQuality,
    CooldownTimer: CooldownTimer,
    CreatePollContent: CreatePollContent,
    CreatePollIcon: CreatePollIcon,
    doFileUploadRequest: doFileUploadRequest,
    editMessage: editMessage,
    FileAttachmentUploadPreview: FileAttachmentUploadPreview,
    FileSelectorIcon: FileSelectorIcon,
    handleAttachButtonPress: handleAttachButtonPress,
    hasCameraPicker: hasCameraPicker,
    hasCommands: hasCommands != null ? hasCommands : !!(clientChannelConfig != null && (_clientChannelConfig$ = clientChannelConfig.commands) != null && _clientChannelConfig$.length),
    hasFilePicker: hasFilePicker,
    hasImagePicker: hasImagePicker,
    ImageAttachmentUploadPreview: ImageAttachmentUploadPreview,
    ImageSelectorIcon: ImageSelectorIcon,
    Input: Input,
    InputButtons: InputButtons,
    InputEditingStateHeader: InputEditingStateHeader,
    InputReplyStateHeader: InputReplyStateHeader,
    MoreOptionsButton: MoreOptionsButton,
    openPollCreationDialog: openPollCreationDialog,
    SendButton: SendButton,
    sendMessage: sendMessage,
    SendMessageDisallowedIndicator: SendMessageDisallowedIndicator,
    setInputRef: setInputRef,
    ShowThreadMessageInChannelButton: ShowThreadMessageInChannelButton,
    StartAudioRecordingButton: StartAudioRecordingButton,
    StopMessageStreamingButton: StopMessageStreamingButton,
    VideoAttachmentUploadPreview: VideoAttachmentUploadPreview,
    VideoRecorderSelectorIcon: VideoRecorderSelectorIcon
  });
  var messageListContext = (0, _useCreatePaginatedMessageListContext.useCreatePaginatedMessageListContext)({
    channelId: channelId,
    hasMore: channelMessagesState.hasMore,
    loadingMore: loadingMoreProp !== undefined ? loadingMoreProp : channelMessagesState.loadingMore,
    loadingMoreRecent: loadingMoreRecentProp !== undefined ? loadingMoreRecentProp : channelMessagesState.loadingMoreRecent,
    loadLatestMessages: loadLatestMessages,
    loadMore: loadMore,
    loadMoreRecent: loadMoreRecent,
    messages: (_channelMessagesState2 = channelMessagesState.messages) != null ? _channelMessagesState2 : []
  });
  var messagesContext = (0, _useCreateMessagesContext.useCreateMessagesContext)({
    additionalPressableProps: additionalPressableProps,
    Attachment: Attachment,
    AttachmentActions: AttachmentActions,
    AudioAttachment: AudioAttachment,
    Card: Card,
    CardCover: CardCover,
    CardFooter: CardFooter,
    CardHeader: CardHeader,
    channelId: channelId,
    DateHeader: DateHeader,
    deletedMessagesVisibilityType: deletedMessagesVisibilityType,
    deleteMessage: deleteMessage,
    deleteReaction: deleteReaction,
    disableTypingIndicator: disableTypingIndicator,
    dismissKeyboardOnMessageTouch: dismissKeyboardOnMessageTouch,
    enableMessageGroupingByUser: enableMessageGroupingByUser,
    enableSwipeToReply: enableSwipeToReply,
    FileAttachment: FileAttachment,
    FileAttachmentGroup: FileAttachmentGroup,
    FileAttachmentIcon: FileAttachmentIcon,
    FlatList: FlatList,
    forceAlignMessages: forceAlignMessages,
    Gallery: Gallery,
    getMessagesGroupStyles: getMessagesGroupStyles,
    Giphy: Giphy,
    giphyVersion: giphyVersion,
    handleBan: handleBan,
    handleCopy: handleCopy,
    handleDelete: handleDelete,
    handleEdit: handleEdit,
    handleFlag: handleFlag,
    handleMarkUnread: handleMarkUnread,
    handleMute: handleMute,
    handlePinMessage: handlePinMessage,
    handleQuotedReply: handleQuotedReply,
    handleReaction: handleReaction,
    handleRetry: handleRetry,
    handleThreadReply: handleThreadReply,
    hasCreatePoll: hasCreatePoll === undefined ? pollCreationEnabled : hasCreatePoll && pollCreationEnabled,
    ImageLoadingFailedIndicator: ImageLoadingFailedIndicator,
    ImageLoadingIndicator: ImageLoadingIndicator,
    ImageReloadIndicator: ImageReloadIndicator,
    initialScrollToFirstUnreadMessage: !messageId && initialScrollToFirstUnreadMessage,
    InlineDateSeparator: InlineDateSeparator,
    InlineUnreadIndicator: InlineUnreadIndicator,
    isAttachmentEqual: isAttachmentEqual,
    isMessageAIGenerated: isMessageAIGenerated,
    legacyImageViewerSwipeBehaviour: legacyImageViewerSwipeBehaviour,
    markdownRules: markdownRules,
    Message: Message,
    MessageActionList: MessageActionList,
    MessageActionListItem: MessageActionListItem,
    messageActions: messageActions,
    MessageAvatar: MessageAvatar,
    MessageBounce: MessageBounce,
    MessageContent: MessageContent,
    messageContentOrder: messageContentOrder,
    MessageDeleted: MessageDeleted,
    MessageEditedTimestamp: MessageEditedTimestamp,
    MessageError: MessageError,
    MessageFooter: MessageFooter,
    MessageHeader: MessageHeader,
    MessageList: MessageList,
    MessageMenu: MessageMenu,
    MessagePinnedHeader: MessagePinnedHeader,
    MessageReactionPicker: MessageReactionPicker,
    MessageReplies: MessageReplies,
    MessageRepliesAvatars: MessageRepliesAvatars,
    MessageSimple: MessageSimple,
    MessageStatus: MessageStatus,
    MessageSwipeContent: MessageSwipeContent,
    messageSwipeToReplyHitSlop: messageSwipeToReplyHitSlop,
    MessageSystem: MessageSystem,
    MessageText: MessageText,
    messageTextNumberOfLines: messageTextNumberOfLines,
    MessageTimestamp: MessageTimestamp,
    MessageUserReactions: MessageUserReactions,
    MessageUserReactionsAvatar: MessageUserReactionsAvatar,
    MessageUserReactionsItem: MessageUserReactionsItem,
    myMessageTheme: myMessageTheme,
    onLongPressMessage: onLongPressMessage,
    onPressInMessage: onPressInMessage,
    onPressMessage: onPressMessage,
    PollContent: PollContent,
    ReactionListBottom: ReactionListBottom,
    reactionListPosition: reactionListPosition,
    ReactionListTop: ReactionListTop,
    removeMessage: removeMessage,
    Reply: Reply,
    retrySendMessage: retrySendMessage,
    ScrollToBottomButton: ScrollToBottomButton,
    selectReaction: selectReaction,
    sendReaction: sendReaction,
    shouldShowUnreadUnderlay: shouldShowUnreadUnderlay,
    StreamingMessageView: StreamingMessageView,
    supportedReactions: supportedReactions,
    targetedMessage: targetedMessage,
    TypingIndicator: TypingIndicator,
    TypingIndicatorContainer: TypingIndicatorContainer,
    UnreadMessagesNotification: UnreadMessagesNotification,
    updateMessage: updateMessage,
    UrlPreview: UrlPreview,
    VideoThumbnail: VideoThumbnail
  });
  var threadContext = (0, _useCreateThreadContext.useCreateThreadContext)({
    allowThreadMessagesInChannel: allowThreadMessagesInChannel,
    closeThread: closeThread,
    loadMoreThread: loadMoreThread,
    openThread: openThread,
    reloadThread: reloadThread,
    setThreadLoadingMore: setThreadLoadingMore,
    thread: thread,
    threadHasMore: threadHasMore,
    threadInstance: threadInstance,
    threadLoadingMore: threadLoadingMore,
    threadMessages: threadMessages
  });
  var typingContext = (0, _useCreateTypingContext.useCreateTypingContext)({
    typing: (_channelState$typing = channelState.typing) != null ? _channelState$typing : {}
  });
  var messageComposerContext = (0, _react.useMemo)(function () {
    return {
      channel: channel,
      thread: thread,
      threadInstance: threadInstance
    };
  }, [channel, thread, threadInstance]);
  if (deleted) {
    return null;
  }
  if (!channel || error && ((_channelMessagesState3 = channelMessagesState.messages) == null ? void 0 : _channelMessagesState3.length) === 0) {
    return (0, _jsxRuntime.jsx)(LoadingErrorIndicator, {
      error: error,
      listType: "message",
      retry: reloadChannel
    });
  }
  if (!(channel != null && channel.cid) || !channel.watch) {
    return (0, _jsxRuntime.jsx)(_reactNative.Text, {
      style: [styles.selectChannel, {
        color: black
      }, selectChannel],
      testID: "no-channel",
      children: t('Please select a channel first')
    });
  }
  return (0, _jsxRuntime.jsx)(KeyboardCompatibleView, Object.assign({
    behavior: keyboardBehavior,
    enabled: !disableKeyboardCompatibleView,
    keyboardVerticalOffset: keyboardVerticalOffset
  }, additionalKeyboardAvoidingViewProps, {
    children: (0, _jsxRuntime.jsx)(_ChannelContext.ChannelProvider, {
      value: channelContext,
      children: (0, _jsxRuntime.jsx)(_OwnCapabilitiesContext.OwnCapabilitiesProvider, {
        value: ownCapabilitiesContext,
        children: (0, _jsxRuntime.jsx)(_TypingContext.TypingProvider, {
          value: typingContext,
          children: (0, _jsxRuntime.jsx)(_PaginatedMessageListContext.PaginatedMessageListProvider, {
            value: messageListContext,
            children: (0, _jsxRuntime.jsx)(_MessagesContext.MessagesProvider, {
              value: messagesContext,
              children: (0, _jsxRuntime.jsx)(_ThreadContext.ThreadProvider, {
                value: threadContext,
                children: (0, _jsxRuntime.jsx)(_contexts.AttachmentPickerProvider, {
                  value: attachmentPickerContext,
                  children: (0, _jsxRuntime.jsx)(_MessageComposerContext.MessageComposerProvider, {
                    value: messageComposerContext,
                    children: (0, _jsxRuntime.jsxs)(_MessageInputContext.MessageInputProvider, {
                      value: inputMessageInputContext,
                      children: [(0, _jsxRuntime.jsx)(_reactNative.View, {
                        style: {
                          height: '100%'
                        },
                        children: children
                      }), (0, _jsxRuntime.jsx)(_AttachmentPicker.AttachmentPicker, Object.assign({
                        ref: bottomSheetRef
                      }, attachmentPickerProps))]
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  }));
};
var Channel = exports.Channel = function Channel(props) {
  var _useChatContext = (0, _ChatContext.useChatContext)(),
    client = _useChatContext.client,
    enableOfflineSupport = _useChatContext.enableOfflineSupport,
    isOnline = _useChatContext.isOnline,
    isMessageAIGenerated = _useChatContext.isMessageAIGenerated;
  var _useTranslationContex = (0, _TranslationContext.useTranslationContext)(),
    t = _useTranslationContex.t;
  var threadFromProps = props == null ? void 0 : props.thread;
  var threadInstance = threadFromProps == null ? void 0 : threadFromProps.threadInstance;
  var threadMessage = threadInstance ? threadFromProps.thread : threadFromProps;
  var thread = {
    thread: threadMessage,
    threadInstance: threadInstance
  };
  var shouldSyncChannel = threadMessage != null && threadMessage.id ? !!props.threadList : true;
  var _useChannelState = (0, _useChannelState2.useChannelState)(props.channel, props.threadList ? threadMessage == null ? void 0 : threadMessage.id : undefined),
    setThreadMessages = _useChannelState.setThreadMessages,
    threadMessages = _useChannelState.threadMessages;
  return (0, _jsxRuntime.jsx)(ChannelWithContext, Object.assign({
    client: client,
    enableOfflineSupport: enableOfflineSupport,
    t: t
  }, props, {
    shouldSyncChannel: shouldSyncChannel,
    isMessageAIGenerated: isMessageAIGenerated,
    isOnline: isOnline,
    setThreadMessages: setThreadMessages,
    thread: thread,
    threadMessages: threadMessages
  }));
};
//# sourceMappingURL=Channel.js.map