var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAudioController = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _reactNative = require("react-native");
var _useMessageComposer2 = require("../../../contexts/messageInputContext/hooks/useMessageComposer");
var _MessageInputContext = require("../../../contexts/messageInputContext/MessageInputContext");
var _native = require("../../../native");
var _types = require("../../../types/types");
var _utils = require("../../../utils/utils");
var _audioSampling = require("../utils/audioSampling");
var _normalizeAudioLevel = require("../utils/normalizeAudioLevel");
var useAudioController = exports.useAudioController = function useAudioController() {
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    micLocked = _useState2[0],
    setMicLocked = _useState2[1];
  var _useState3 = (0, _react.useState)(true),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    permissionsGranted = _useState4[0],
    setPermissionsGranted = _useState4[1];
  var _useState5 = (0, _react.useState)(true),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    paused = _useState6[0],
    setPaused = _useState6[1];
  var _useState7 = (0, _react.useState)(0),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    position = _useState8[0],
    setPosition = _useState8[1];
  var _useState9 = (0, _react.useState)(0),
    _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
    progress = _useState10[0],
    setProgress = _useState10[1];
  var _useState11 = (0, _react.useState)([]),
    _useState12 = (0, _slicedToArray2.default)(_useState11, 2),
    waveformData = _useState12[0],
    setWaveformData = _useState12[1];
  var _useState13 = (0, _react.useState)(false),
    _useState14 = (0, _slicedToArray2.default)(_useState13, 2),
    isScheduledForSubmit = _useState14[0],
    setIsScheduleForSubmit = _useState14[1];
  var _useState15 = (0, _react.useState)(undefined),
    _useState16 = (0, _slicedToArray2.default)(_useState15, 2),
    recording = _useState16[0],
    setRecording = _useState16[1];
  var _useState17 = (0, _react.useState)(0),
    _useState18 = (0, _slicedToArray2.default)(_useState17, 2),
    recordingDuration = _useState18[0],
    setRecordingDuration = _useState18[1];
  var _useState19 = (0, _react.useState)('idle'),
    _useState20 = (0, _slicedToArray2.default)(_useState19, 2),
    recordingStatus = _useState20[0],
    setRecordingStatus = _useState20[1];
  var _useMessageComposer = (0, _useMessageComposer2.useMessageComposer)(),
    attachmentManager = _useMessageComposer.attachmentManager;
  var _useMessageInputConte = (0, _MessageInputContext.useMessageInputContext)(),
    sendMessage = _useMessageInputConte.sendMessage;
  var soundRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(function () {
    return function () {
      stopVoicePlayer();
      stopSDKVoiceRecording();
    };
  }, []);
  (0, _react.useEffect)(function () {
    if (isScheduledForSubmit) {
      sendMessage();
      setIsScheduleForSubmit(false);
    }
  }, [isScheduledForSubmit, sendMessage]);
  var onVoicePlayerProgressHandler = function onVoicePlayerProgressHandler(currentPosition, playbackDuration) {
    var currentProgress = currentPosition / playbackDuration;
    if (currentProgress === 1) {
      setPaused(true);
      setProgress(0);
    } else {
      setProgress(currentProgress);
    }
  };
  var onVoicePlayerPlaybackStatusUpdate = function onVoicePlayerPlaybackStatusUpdate(status) {
    if (status.shouldPlay === undefined || status.shouldPlay === true) {
      setPosition((status == null ? void 0 : status.currentPosition) || (status == null ? void 0 : status.positionMillis));
      setRecordingDuration(status.duration || status.durationMillis);
      if (status.didJustFinish) {
        onVoicePlayerProgressHandler(status.durationMillis, status.durationMillis);
      } else {
        if (status.currentPosition && status.duration) {
          onVoicePlayerProgressHandler(status.currentPosition, status.duration);
        } else if (status.positionMillis && status.durationMillis) {
          onVoicePlayerProgressHandler(status.positionMillis, status.durationMillis);
        }
      }
    }
  };
  var onVoicePlayerPlayPause = function () {
    var _ref = (0, _asyncToGenerator2.default)(function* () {
      if (paused) {
        if (progress === 0) {
          yield startVoicePlayer();
        } else {
          var _NativeHandlers$Audio, _soundRef$current;
          if ((_NativeHandlers$Audio = _native.NativeHandlers.Audio) != null && _NativeHandlers$Audio.resumePlayer) {
            yield _native.NativeHandlers.Audio.resumePlayer();
          }
          if ((_soundRef$current = soundRef.current) != null && _soundRef$current.playAsync) {
            yield soundRef.current.playAsync();
          }
        }
      } else {
        var _NativeHandlers$Audio2, _soundRef$current2;
        if ((_NativeHandlers$Audio2 = _native.NativeHandlers.Audio) != null && _NativeHandlers$Audio2.pausePlayer) {
          yield _native.NativeHandlers.Audio.pausePlayer();
        }
        if ((_soundRef$current2 = soundRef.current) != null && _soundRef$current2.pauseAsync) {
          yield soundRef.current.pauseAsync();
        }
      }
      setPaused(!paused);
    });
    return function onVoicePlayerPlayPause() {
      return _ref.apply(this, arguments);
    };
  }();
  var startVoicePlayer = function () {
    var _ref2 = (0, _asyncToGenerator2.default)(function* () {
      var _NativeHandlers$Audio3;
      if (!recording) {
        return;
      }
      if ((_NativeHandlers$Audio3 = _native.NativeHandlers.Audio) != null && _NativeHandlers$Audio3.startPlayer) {
        yield _native.NativeHandlers.Audio.startPlayer(recording, {}, onVoicePlayerPlaybackStatusUpdate);
      }
      if (recording && typeof recording !== 'string') {
        var _NativeHandlers$Sound;
        var uri = recording.getURI();
        if (uri && (_NativeHandlers$Sound = _native.NativeHandlers.Sound) != null && _NativeHandlers$Sound.initializeSound) {
          var _soundRef$current3;
          if ((_soundRef$current3 = soundRef.current) != null && _soundRef$current3.replayAsync) {
            yield soundRef.current.replayAsync({});
          } else {
            var _soundRef$current4;
            soundRef.current = yield _native.NativeHandlers.Sound.initializeSound({
              uri: uri
            }, {
              progressUpdateIntervalMillis: _reactNative.Platform.OS === 'android' ? 100 : 60
            }, onVoicePlayerPlaybackStatusUpdate);
            if ((_soundRef$current4 = soundRef.current) != null && _soundRef$current4.playAsync) {
              yield soundRef.current.playAsync();
            }
          }
        }
      }
    });
    return function startVoicePlayer() {
      return _ref2.apply(this, arguments);
    };
  }();
  var stopVoicePlayer = function () {
    var _ref3 = (0, _asyncToGenerator2.default)(function* () {
      var _NativeHandlers$Audio4, _soundRef$current5, _soundRef$current6;
      if ((_NativeHandlers$Audio4 = _native.NativeHandlers.Audio) != null && _NativeHandlers$Audio4.stopPlayer) {
        yield _native.NativeHandlers.Audio.stopPlayer();
      }
      if ((_soundRef$current5 = soundRef.current) != null && _soundRef$current5.stopAsync && (_soundRef$current6 = soundRef.current) != null && _soundRef$current6.unloadAsync) {
        var _soundRef$current7;
        yield soundRef.current.stopAsync();
        yield (_soundRef$current7 = soundRef.current) == null ? void 0 : _soundRef$current7.unloadAsync();
      }
    });
    return function stopVoicePlayer() {
      return _ref3.apply(this, arguments);
    };
  }();
  var onRecordingStatusUpdate = function onRecordingStatusUpdate(status) {
    if (status.isDoneRecording === true) {
      return;
    }
    setRecordingDuration((status == null ? void 0 : status.currentPosition) || status.durationMillis);
    var lowerBound = _reactNative.Platform.OS === 'ios' || status.currentMetering ? -60 : -120;
    var normalizedAudioLevel = (0, _normalizeAudioLevel.normalizeAudioLevel)(status.currentMetering || status.metering, lowerBound);
    setWaveformData(function (prev) {
      return [].concat((0, _toConsumableArray2.default)(prev), [normalizedAudioLevel]);
    });
  };
  var startVoiceRecording = function () {
    var _ref4 = (0, _asyncToGenerator2.default)(function* () {
      if (!_native.NativeHandlers.Audio) {
        return;
      }
      var recordingInfo = yield _native.NativeHandlers.Audio.startRecording({
        isMeteringEnabled: true
      }, onRecordingStatusUpdate);
      var accessGranted = recordingInfo.accessGranted;
      if (accessGranted) {
        setPermissionsGranted(true);
        var _recording = recordingInfo.recording;
        if (_recording && typeof _recording !== 'string' && _recording.setProgressUpdateInterval) {
          _recording.setProgressUpdateInterval(_reactNative.Platform.OS === 'android' ? 100 : 60);
        }
        setRecording(_recording);
        setRecordingStatus('recording');
        yield stopVoicePlayer();
      } else {
        setPermissionsGranted(false);
        resetState();
        _reactNative.Alert.alert('Please allow Audio permissions in settings.');
      }
    });
    return function startVoiceRecording() {
      return _ref4.apply(this, arguments);
    };
  }();
  var stopSDKVoiceRecording = function () {
    var _ref5 = (0, _asyncToGenerator2.default)(function* () {
      if (!_native.NativeHandlers.Audio) {
        return;
      }
      yield _native.NativeHandlers.Audio.stopRecording();
    });
    return function stopSDKVoiceRecording() {
      return _ref5.apply(this, arguments);
    };
  }();
  var stopVoiceRecording = function () {
    var _ref6 = (0, _asyncToGenerator2.default)(function* () {
      yield stopSDKVoiceRecording();
      setRecordingStatus('stopped');
    });
    return function stopVoiceRecording() {
      return _ref6.apply(this, arguments);
    };
  }();
  var resetState = function resetState() {
    setRecording(undefined);
    setRecordingStatus('idle');
    setMicLocked(false);
    setWaveformData([]);
    setPaused(true);
    setPosition(0);
    setProgress(0);
  };
  var deleteVoiceRecording = function () {
    var _ref7 = (0, _asyncToGenerator2.default)(function* () {
      if (recordingStatus === 'recording') {
        yield stopVoiceRecording();
      }
      if (!paused) {
        yield stopVoicePlayer();
      }
      resetState();
      _native.NativeHandlers.triggerHaptic('impactMedium');
    });
    return function deleteVoiceRecording() {
      return _ref7.apply(this, arguments);
    };
  }();
  var uploadVoiceRecording = function () {
    var _ref8 = (0, _asyncToGenerator2.default)(function* (multiSendEnabled) {
      if (!paused) {
        yield stopVoicePlayer();
      }
      if (recordingStatus === 'recording') {
        yield stopVoiceRecording();
      }
      var durationInSeconds = parseFloat((recordingDuration / 1000).toFixed(3));
      var resampledWaveformData = (0, _audioSampling.resampleWaveformData)(waveformData, 100);
      var clearFilter = new RegExp('[.:]', 'g');
      var date = new Date().toISOString().replace(clearFilter, '_');
      var file = {
        duration: durationInSeconds,
        name: `audio_recording_${date}.aac`,
        size: 0,
        type: 'audio/aac',
        uri: typeof recording !== 'string' ? recording == null ? void 0 : recording.getURI() : recording,
        waveform_data: resampledWaveformData
      };
      var audioFile = {
        asset_url: typeof recording !== 'string' ? recording == null ? void 0 : recording.getURI() : recording,
        duration: durationInSeconds,
        file_size: 0,
        localMetadata: {
          file: file,
          id: (0, _utils.generateRandomId)(),
          uploadState: 'pending'
        },
        mime_type: 'audio/aac',
        title: `audio_recording_${date}.aac`,
        type: _types.FileTypes.VoiceRecording,
        waveform_data: resampledWaveformData
      };
      if (multiSendEnabled) {
        yield attachmentManager.uploadAttachment(audioFile);
      } else {
        yield attachmentManager.uploadAttachment(audioFile);
        setIsScheduleForSubmit(true);
      }
      resetState();
    });
    return function uploadVoiceRecording(_x) {
      return _ref8.apply(this, arguments);
    };
  }();
  return {
    deleteVoiceRecording: deleteVoiceRecording,
    micLocked: micLocked,
    onVoicePlayerPlayPause: onVoicePlayerPlayPause,
    paused: paused,
    permissionsGranted: permissionsGranted,
    position: position,
    progress: progress,
    recording: recording,
    recordingDuration: recordingDuration,
    recordingStatus: recordingStatus,
    setMicLocked: setMicLocked,
    setRecording: setRecording,
    setRecordingDuration: setRecordingDuration,
    setRecordingStatus: setRecordingStatus,
    setWaveformData: setWaveformData,
    startVoiceRecording: startVoiceRecording,
    stopVoiceRecording: stopVoiceRecording,
    uploadVoiceRecording: uploadVoiceRecording,
    waveformData: waveformData
  };
};
//# sourceMappingURL=useAudioController.js.map