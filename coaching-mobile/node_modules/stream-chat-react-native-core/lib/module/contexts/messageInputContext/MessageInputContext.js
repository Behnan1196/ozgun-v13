var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMessageInputContext = exports.MessageInputProvider = exports.MessageInputContext = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _streamChat = require("stream-chat");
var _useAttachmentManagerState = require("./hooks/useAttachmentManagerState");
var _useCreateMessageInputContext = require("./hooks/useCreateMessageInputContext");
var _useMessageComposer = require("./hooks/useMessageComposer");
var _parseLinks = require("../../components/Message/MessageSimple/utils/parseLinks");
var _useCooldown2 = require("../../components/MessageInput/hooks/useCooldown");
var _useStableCallback = require("../../hooks/useStableCallback");
var _attachments = require("../../middlewares/attachments");
var _native = require("../../native");
var _compressImage = require("../../utils/compressImage");
var _AttachmentPickerContext = require("../attachmentPickerContext/AttachmentPickerContext");
var _ChannelContext = require("../channelContext/ChannelContext");
var _ChatContext = require("../chatContext/ChatContext");
var _MessageComposerAPIContext = require("../messageComposerContext/MessageComposerAPIContext");
var _OwnCapabilitiesContext = require("../ownCapabilitiesContext/OwnCapabilitiesContext");
var _ThreadContext = require("../threadContext/ThreadContext");
var _TranslationContext = require("../translationContext/TranslationContext");
var _defaultBaseContextValue = require("../utils/defaultBaseContextValue");
var _isTestEnvironment = require("../utils/isTestEnvironment");
var _jsxRuntime = require("react/jsx-runtime");
var _this = this,
  _jsxFileName = "/home/runner/work/stream-chat-react-native/stream-chat-react-native/package/src/contexts/messageInputContext/MessageInputContext.tsx";
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var MessageInputContext = exports.MessageInputContext = _react.default.createContext(_defaultBaseContextValue.DEFAULT_BASE_CONTEXT_VALUE);
var MessageInputProvider = exports.MessageInputProvider = function MessageInputProvider(_ref) {
  var children = _ref.children,
    value = _ref.value;
  var _useAttachmentPickerC = (0, _AttachmentPickerContext.useAttachmentPickerContext)(),
    closePicker = _useAttachmentPickerC.closePicker,
    openPicker = _useAttachmentPickerC.openPicker,
    selectedPicker = _useAttachmentPickerC.selectedPicker,
    setSelectedPicker = _useAttachmentPickerC.setSelectedPicker;
  var _useChatContext = (0, _ChatContext.useChatContext)(),
    client = _useChatContext.client,
    enableOfflineSupport = _useChatContext.enableOfflineSupport;
  var channelCapabilities = (0, _OwnCapabilitiesContext.useOwnCapabilitiesContext)();
  var _useChannelContext = (0, _ChannelContext.useChannelContext)(),
    uploadAbortControllerRef = _useChannelContext.uploadAbortControllerRef;
  var _useMessageComposerAP = (0, _MessageComposerAPIContext.useMessageComposerAPIContext)(),
    clearEditingState = _useMessageComposerAP.clearEditingState;
  var _useThreadContext = (0, _ThreadContext.useThreadContext)(),
    thread = _useThreadContext.thread;
  var _useTranslationContex = (0, _TranslationContext.useTranslationContext)(),
    t = _useTranslationContex.t;
  var inputBoxRef = (0, _react.useRef)(null);
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    showPollCreationDialog = _useState2[0],
    setShowPollCreationDialog = _useState2[1];
  var defaultOpenPollCreationDialog = (0, _react.useCallback)(function () {
    return setShowPollCreationDialog(true);
  }, []);
  var closePollCreationDialog = (0, _react.useCallback)(function () {
    return setShowPollCreationDialog(false);
  }, []);
  var openPollCreationDialogFromContext = value.openPollCreationDialog;
  var _useCooldown = (0, _useCooldown2.useCooldown)(),
    cooldownEndsAt = _useCooldown.endsAt,
    startCooldown = _useCooldown.start;
  var messageComposer = (0, _useMessageComposer.useMessageComposer)();
  var attachmentManager = messageComposer.attachmentManager,
    editedMessage = messageComposer.editedMessage;
  var _useAttachmentManager = (0, _useAttachmentManagerState.useAttachmentManagerState)(),
    availableUploadSlots = _useAttachmentManager.availableUploadSlots;
  (0, _react.useEffect)(function () {
    if (value.doFileUploadRequest) {
      attachmentManager.setCustomUploadFn(value.doFileUploadRequest);
    }
    if (enableOfflineSupport) {
      messageComposer.compositionMiddlewareExecutor.replace([(0, _attachments.createAttachmentsCompositionMiddleware)(messageComposer)]);
      messageComposer.draftCompositionMiddlewareExecutor.replace([(0, _attachments.createDraftAttachmentsCompositionMiddleware)(messageComposer)]);
    }
  }, [value.doFileUploadRequest, enableOfflineSupport, messageComposer, attachmentManager]);
  var takeAndUploadImage = (0, _useStableCallback.useStableCallback)(function () {
    var _ref2 = (0, _asyncToGenerator2.default)(function* (mediaType) {
      if (!availableUploadSlots) {
        _reactNative.Alert.alert(t('Maximum number of files reached'));
        return;
      }
      var file = yield _native.NativeHandlers.takePhoto({
        compressImageQuality: value.compressImageQuality,
        mediaType: mediaType
      });
      if (file.askToOpenSettings) {
        _reactNative.Alert.alert(t('Allow camera access in device settings'), t('Device camera is used to take photos or videos.'), [{
          style: 'cancel',
          text: t('Cancel')
        }, {
          onPress: function onPress() {
            return _reactNative.Linking.openSettings();
          },
          style: 'default',
          text: t('Open Settings')
        }]);
      }
      if (file.cancelled) {
        return;
      }
      yield uploadNewFile(file);
    });
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }());
  var pickAndUploadImageFromNativePicker = (0, _useStableCallback.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    var _result$assets;
    if (!availableUploadSlots) {
      _reactNative.Alert.alert(t('Maximum number of files reached'));
      return;
    }
    var result = yield _native.NativeHandlers.pickImage();
    if (result.askToOpenSettings) {
      _reactNative.Alert.alert(t('Allow access to your Gallery'), t('Device gallery permissions is used to take photos or videos.'), [{
        style: 'cancel',
        text: t('Cancel')
      }, {
        onPress: function onPress() {
          return _reactNative.Linking.openSettings();
        },
        style: 'default',
        text: t('Open Settings')
      }]);
    }
    if (result.cancelled || !((_result$assets = result.assets) != null && _result$assets.length)) {
      return;
    }
    result.assets.forEach(function () {
      var _ref4 = (0, _asyncToGenerator2.default)(function* (asset) {
        yield uploadNewFile(asset);
      });
      return function (_x2) {
        return _ref4.apply(this, arguments);
      };
    }());
  }));
  var pickFile = (0, _useStableCallback.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    var _result$assets2;
    if (!(0, _native.isDocumentPickerAvailable)()) {
      console.log('The file picker is not installed. Check our Getting Started documentation to install it.');
      return;
    }
    if (!availableUploadSlots) {
      _reactNative.Alert.alert(t('Maximum number of files reached'));
      return;
    }
    var result = yield _native.NativeHandlers.pickDocument({
      maxNumberOfFiles: availableUploadSlots
    });
    if (result.cancelled || !((_result$assets2 = result.assets) != null && _result$assets2.length)) {
      return;
    }
    result.assets.forEach(function () {
      var _ref6 = (0, _asyncToGenerator2.default)(function* (asset) {
        yield uploadNewFile(asset);
      });
      return function (_x3) {
        return _ref6.apply(this, arguments);
      };
    }());
  }));
  var openAttachmentPicker = (0, _react.useCallback)(function () {
    _reactNative.Keyboard.dismiss();
    setSelectedPicker('images');
    openPicker();
  }, [openPicker, setSelectedPicker]);
  var closeAttachmentPicker = (0, _react.useCallback)(function () {
    setSelectedPicker(undefined);
    closePicker();
  }, [closePicker, setSelectedPicker]);
  var toggleAttachmentPicker = (0, _react.useCallback)(function () {
    if (selectedPicker) {
      closeAttachmentPicker();
    } else {
      openAttachmentPicker();
    }
  }, [closeAttachmentPicker, openAttachmentPicker, selectedPicker]);
  var sendMessage = (0, _useStableCallback.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    startCooldown();
    if (inputBoxRef.current) {
      inputBoxRef.current.clear();
    }
    try {
      var composition = yield messageComposer.compose();
      if (!composition && editedMessage) {
        clearEditingState();
      }
      if (!composition || !composition.message) return;
      var localMessage = composition.localMessage,
        message = composition.message,
        sendOptions = composition.sendOptions;
      var linkInfos = (0, _parseLinks.parseLinksFromText)(localMessage.text);
      if (!channelCapabilities.sendLinks && linkInfos.length > 0) {
        _reactNative.Alert.alert(t('Links are disabled'), t('Sending links is not allowed in this conversation'));
        return;
      }
      if (editedMessage && editedMessage.type !== 'error') {
        try {
          clearEditingState();
          yield value.editMessage({
            localMessage: localMessage,
            options: sendOptions
          });
        } catch (error) {
          throw new Error('Error while editing message');
        }
      } else {
        try {
          if (localMessage.poll_id) {
            messageComposer.state.partialNext({
              id: _streamChat.MessageComposer.generateId(),
              pollId: null
            });
          } else {
            messageComposer.clear();
          }
          yield value.sendMessage({
            localMessage: localMessage,
            message: message,
            options: sendOptions
          });
        } catch (error) {
          throw new Error('Error while sending message');
        }
      }
    } catch (error) {
      console.error('Error while sending message:', error);
    }
  }));
  var setInputBoxRef = (0, _useStableCallback.useStableCallback)(function (ref) {
    inputBoxRef.current = ref;
    if (value.setInputRef) {
      value.setInputRef(ref);
    }
  });
  var uploadNewFile = (0, _useStableCallback.useStableCallback)(function () {
    var _ref8 = (0, _asyncToGenerator2.default)(function* (file) {
      try {
        uploadAbortControllerRef.current.set(file.name, client.createAbortControllerForNextRequest());
        var fileURI = file.type.includes('image') ? yield (0, _compressImage.compressedImageURI)(file, value.compressImageQuality) : file.uri;
        var updatedFile = Object.assign({}, file, {
          uri: fileURI
        });
        yield attachmentManager.uploadFiles([updatedFile]);
        uploadAbortControllerRef.current.delete(file.name);
      } catch (error) {
        if (error instanceof Error && (error.name === 'AbortError' || error.name === 'CanceledError')) {
          uploadAbortControllerRef.current.delete(file.name);
          return;
        }
      }
    });
    return function (_x4) {
      return _ref8.apply(this, arguments);
    };
  }());
  var openPollCreationDialog = (0, _useStableCallback.useStableCallback)(function () {
    if (openPollCreationDialogFromContext) {
      openPollCreationDialogFromContext({
        sendMessage: sendMessage
      });
      return;
    }
    defaultOpenPollCreationDialog();
  });
  var messageInputContext = (0, _useCreateMessageInputContext.useCreateMessageInputContext)(Object.assign({
    closeAttachmentPicker: closeAttachmentPicker,
    cooldownEndsAt: cooldownEndsAt,
    inputBoxRef: inputBoxRef,
    openAttachmentPicker: openAttachmentPicker,
    pickAndUploadImageFromNativePicker: pickAndUploadImageFromNativePicker,
    pickFile: pickFile,
    setInputBoxRef: setInputBoxRef,
    takeAndUploadImage: takeAndUploadImage,
    thread: thread,
    toggleAttachmentPicker: toggleAttachmentPicker,
    uploadNewFile: uploadNewFile
  }, value, {
    closePollCreationDialog: closePollCreationDialog,
    openPollCreationDialog: openPollCreationDialog,
    selectedPicker: selectedPicker,
    sendMessage: sendMessage,
    showPollCreationDialog: showPollCreationDialog
  }));
  return (0, _jsxRuntime.jsx)(MessageInputContext.Provider, {
    value: messageInputContext,
    children: children
  });
};
var useMessageInputContext = exports.useMessageInputContext = function useMessageInputContext() {
  var contextValue = (0, _react.useContext)(MessageInputContext);
  if (contextValue === _defaultBaseContextValue.DEFAULT_BASE_CONTEXT_VALUE && !(0, _isTestEnvironment.isTestEnvironment)()) {
    throw new Error('The useMessageInputContext hook was called outside of the MessageInputContext provider. Make sure you have configured Channel component correctly - https://getstream.io/chat/docs/sdk/reactnative/basics/hello_stream_chat/#channel');
  }
  return contextValue;
};
//# sourceMappingURL=MessageInputContext.js.map