Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCreateMessageComposer = void 0;
var _react = require("react");
var _streamChat = require("stream-chat");
var _ChatContext = require("../../chatContext/ChatContext");
var queueCache = new _streamChat.FixedSizeQueueCache(64);
var useCreateMessageComposer = exports.useCreateMessageComposer = function useCreateMessageComposer(_ref) {
  var editedMessage = _ref.editing,
    parentMessage = _ref.thread,
    threadInstance = _ref.threadInstance,
    channel = _ref.channel;
  var _useChatContext = (0, _ChatContext.useChatContext)(),
    client = _useChatContext.client;
  var cachedEditedMessage = (0, _react.useMemo)(function () {
    if (!editedMessage) return undefined;
    return editedMessage;
  }, [editedMessage == null ? void 0 : editedMessage.id]);
  var cachedParentMessage = (0, _react.useMemo)(function () {
    if (!parentMessage) return undefined;
    return parentMessage;
  }, [parentMessage == null ? void 0 : parentMessage.id]);
  var messageComposer = (0, _react.useMemo)(function () {
    if (cachedEditedMessage) {
      var tag = _streamChat.MessageComposer.constructTag(cachedEditedMessage);
      var cachedComposer = queueCache.get(tag);
      if (cachedComposer) return cachedComposer;
      return new _streamChat.MessageComposer({
        client: client,
        composition: cachedEditedMessage,
        compositionContext: cachedEditedMessage
      });
    } else if (threadInstance) {
      return threadInstance.messageComposer;
    } else if (cachedParentMessage) {
      var compositionContext = Object.assign({}, cachedParentMessage, {
        legacyThreadId: cachedParentMessage.id
      });
      var _tag = _streamChat.MessageComposer.constructTag(compositionContext);
      var _cachedComposer = queueCache.get(_tag);
      if (_cachedComposer) return _cachedComposer;
      return new _streamChat.MessageComposer({
        client: client,
        compositionContext: compositionContext
      });
    } else {
      return channel.messageComposer;
    }
  }, [cachedEditedMessage, cachedParentMessage, channel, client, threadInstance]);
  if (['legacy_thread', 'message'].includes(messageComposer.contextType) && !queueCache.peek(messageComposer.tag)) {
    queueCache.add(messageComposer.tag, messageComposer);
  }
  (0, _react.useEffect)(function () {
    var unsubscribe = messageComposer.registerSubscriptions();
    return function () {
      unsubscribe();
    };
  }, [messageComposer]);
  return messageComposer;
};
//# sourceMappingURL=useCreateMessageComposer.js.map