var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageInput = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeGestureHandler = require("react-native-gesture-handler");
var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));
var _useAudioController2 = require("./hooks/useAudioController");
var _useCountdown2 = require("./hooks/useCountdown");
var _contexts = require("../../contexts");
var _AttachmentPickerContext = require("../../contexts/attachmentPickerContext/AttachmentPickerContext");
var _ChannelContext = require("../../contexts/channelContext/ChannelContext");
var _MessageComposerAPIContext = require("../../contexts/messageComposerContext/MessageComposerAPIContext");
var _useAttachmentManagerState = require("../../contexts/messageInputContext/hooks/useAttachmentManagerState");
var _useMessageComposer = require("../../contexts/messageInputContext/hooks/useMessageComposer");
var _useMessageComposerHasSendableData = require("../../contexts/messageInputContext/hooks/useMessageComposerHasSendableData");
var _MessageInputContext = require("../../contexts/messageInputContext/MessageInputContext");
var _MessagesContext = require("../../contexts/messagesContext/MessagesContext");
var _ThemeContext = require("../../contexts/themeContext/ThemeContext");
var _TranslationContext = require("../../contexts/translationContext/TranslationContext");
var _useStateStore3 = require("../../hooks/useStateStore");
var _native = require("../../native");
var _AITypingIndicatorView = require("../AITypingIndicatorView");
var _AutoCompleteInput = require("../AutoCompleteInput/AutoCompleteInput");
var _CreatePollContent = require("../Poll/CreatePollContent");
var _jsxRuntime = require("react/jsx-runtime");
var _this = this,
  _jsxFileName = "/home/runner/work/stream-chat-react-native/stream-chat-react-native/package/src/components/MessageInput/MessageInput.tsx";
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var styles = _reactNative.StyleSheet.create({
  attachmentSeparator: {
    borderBottomWidth: 1,
    marginBottom: 10
  },
  autoCompleteInputContainer: {
    alignItems: 'center',
    flexDirection: 'row',
    paddingLeft: 16,
    paddingRight: 16
  },
  composerContainer: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between'
  },
  container: {
    borderTopWidth: 1,
    padding: 10
  },
  inputBoxContainer: {
    borderRadius: 20,
    borderWidth: 1,
    flex: 1,
    marginHorizontal: 10
  },
  micButtonContainer: {},
  optionsContainer: {
    flexDirection: 'row'
  },
  replyContainer: {
    paddingBottom: 12,
    paddingHorizontal: 8
  },
  sendButtonContainer: {},
  suggestionsListContainer: {
    position: 'absolute',
    width: '100%'
  }
});
var textComposerStateSelector = function textComposerStateSelector(state) {
  return {
    command: state.command,
    hasText: !!state.text,
    mentionedUsers: state.mentionedUsers,
    suggestions: state.suggestions
  };
};
var messageComposerStateStoreSelector = function messageComposerStateStoreSelector(state) {
  return {
    quotedMessage: state.quotedMessage
  };
};
var MessageInputWithContext = function MessageInputWithContext(props) {
  var _inputBoxRef$current;
  var AttachmentPickerSelectionBar = props.AttachmentPickerSelectionBar,
    attachmentPickerBottomSheetHeight = props.attachmentPickerBottomSheetHeight,
    attachmentSelectionBarHeight = props.attachmentSelectionBarHeight,
    bottomInset = props.bottomInset,
    selectedPicker = props.selectedPicker,
    additionalTextInputProps = props.additionalTextInputProps,
    asyncMessagesLockDistance = props.asyncMessagesLockDistance,
    asyncMessagesMinimumPressDuration = props.asyncMessagesMinimumPressDuration,
    asyncMessagesMultiSendEnabled = props.asyncMessagesMultiSendEnabled,
    asyncMessagesSlideToCancelDistance = props.asyncMessagesSlideToCancelDistance,
    AttachmentUploadPreviewList = props.AttachmentUploadPreviewList,
    AudioRecorder = props.AudioRecorder,
    audioRecordingEnabled = props.audioRecordingEnabled,
    AudioRecordingInProgress = props.AudioRecordingInProgress,
    AudioRecordingLockIndicator = props.AudioRecordingLockIndicator,
    AudioRecordingPreview = props.AudioRecordingPreview,
    AutoCompleteSuggestionList = props.AutoCompleteSuggestionList,
    channel = props.channel,
    closeAttachmentPicker = props.closeAttachmentPicker,
    closePollCreationDialog = props.closePollCreationDialog,
    cooldownEndsAt = props.cooldownEndsAt,
    CooldownTimer = props.CooldownTimer,
    CreatePollContent = props.CreatePollContent,
    editing = props.editing,
    Input = props.Input,
    inputBoxRef = props.inputBoxRef,
    InputButtons = props.InputButtons,
    InputEditingStateHeader = props.InputEditingStateHeader,
    CommandInput = props.CommandInput,
    InputReplyStateHeader = props.InputReplyStateHeader,
    isOnline = props.isOnline,
    members = props.members,
    Reply = props.Reply,
    threadList = props.threadList,
    SendButton = props.SendButton,
    sendMessage = props.sendMessage,
    showPollCreationDialog = props.showPollCreationDialog,
    ShowThreadMessageInChannelButton = props.ShowThreadMessageInChannelButton,
    StartAudioRecordingButton = props.StartAudioRecordingButton,
    StopMessageStreamingButton = props.StopMessageStreamingButton,
    watchers = props.watchers;
  var messageComposer = (0, _useMessageComposer.useMessageComposer)();
  var textComposer = messageComposer.textComposer;
  var _useStateStore = (0, _useStateStore3.useStateStore)(textComposer.state, textComposerStateSelector),
    command = _useStateStore.command,
    hasText = _useStateStore.hasText;
  var _useStateStore2 = (0, _useStateStore3.useStateStore)(messageComposer.state, messageComposerStateStoreSelector),
    quotedMessage = _useStateStore2.quotedMessage;
  var _useAttachmentManager = (0, _useAttachmentManagerState.useAttachmentManagerState)(),
    attachments = _useAttachmentManager.attachments;
  var hasSendableData = (0, _useMessageComposerHasSendableData.useMessageComposerHasSendableData)();
  var _useState = (0, _react.useState)(0),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    height = _useState2[0],
    setHeight = _useState2[1];
  var _useTheme = (0, _ThemeContext.useTheme)(),
    _useTheme$theme = _useTheme.theme,
    _useTheme$theme$color = _useTheme$theme.colors,
    border = _useTheme$theme$color.border,
    grey_whisper = _useTheme$theme$color.grey_whisper,
    white = _useTheme$theme$color.white,
    white_smoke = _useTheme$theme$color.white_smoke,
    _useTheme$theme$messa = _useTheme$theme.messageInput,
    attachmentSelectionBar = _useTheme$theme$messa.attachmentSelectionBar,
    autoCompleteInputContainer = _useTheme$theme$messa.autoCompleteInputContainer,
    composerContainer = _useTheme$theme$messa.composerContainer,
    container = _useTheme$theme$messa.container,
    focusedInputBoxContainer = _useTheme$theme$messa.focusedInputBoxContainer,
    inputBoxContainer = _useTheme$theme$messa.inputBoxContainer,
    micButtonContainer = _useTheme$theme$messa.micButtonContainer,
    optionsContainer = _useTheme$theme$messa.optionsContainer,
    replyContainer = _useTheme$theme$messa.replyContainer,
    sendButtonContainer = _useTheme$theme$messa.sendButtonContainer,
    suggestionListContainer = _useTheme$theme$messa.suggestionsListContainer.container;
  var _useCountdown = (0, _useCountdown2.useCountdown)(cooldownEndsAt),
    cooldownRemainingSeconds = _useCountdown.seconds;
  (0, _react.useEffect)(function () {
    return function () {
      closeAttachmentPicker();
    };
  }, [closeAttachmentPicker]);
  (0, _react.useEffect)(function () {
    if (editing && inputBoxRef.current) {
      inputBoxRef.current.focus();
    }
  }, [editing, inputBoxRef]);
  (0, _react.useEffect)(function () {
    var threadId = messageComposer.threadId;
    if (!threadId) return;
    messageComposer.getDraft();
  }, [messageComposer]);
  var getMembers = function getMembers() {
    var result = [];
    if (members && Object.values(members).length) {
      Object.values(members).forEach(function (member) {
        if (member.user) {
          result.push(member.user);
        }
      });
    }
    return result;
  };
  var getUsers = function getUsers() {
    var users = [].concat((0, _toConsumableArray2.default)(getMembers()), (0, _toConsumableArray2.default)(getWatchers()));
    var uniqueUsers = {};
    for (var user of users) {
      if (user && !uniqueUsers[user.id]) {
        uniqueUsers[user.id] = user;
      }
    }
    var usersArray = Object.values(uniqueUsers);
    return usersArray;
  };
  var getWatchers = function getWatchers() {
    var result = [];
    if (watchers && Object.values(watchers).length) {
      result.push.apply(result, (0, _toConsumableArray2.default)(Object.values(watchers)));
    }
    return result;
  };
  var isFocused = (_inputBoxRef$current = inputBoxRef.current) == null ? void 0 : _inputBoxRef$current.isFocused();
  var _useAudioController = (0, _useAudioController2.useAudioController)(),
    deleteVoiceRecording = _useAudioController.deleteVoiceRecording,
    micLocked = _useAudioController.micLocked,
    onVoicePlayerPlayPause = _useAudioController.onVoicePlayerPlayPause,
    paused = _useAudioController.paused,
    permissionsGranted = _useAudioController.permissionsGranted,
    position = _useAudioController.position,
    progress = _useAudioController.progress,
    recording = _useAudioController.recording,
    recordingDuration = _useAudioController.recordingDuration,
    recordingStatus = _useAudioController.recordingStatus,
    setMicLocked = _useAudioController.setMicLocked,
    startVoiceRecording = _useAudioController.startVoiceRecording,
    stopVoiceRecording = _useAudioController.stopVoiceRecording,
    uploadVoiceRecording = _useAudioController.uploadVoiceRecording,
    waveformData = _useAudioController.waveformData;
  var asyncAudioEnabled = audioRecordingEnabled && (0, _native.isAudioRecorderAvailable)();
  var showSendingButton = hasText || attachments.length || command;
  var isSendingButtonVisible = (0, _react.useMemo)(function () {
    return asyncAudioEnabled ? showSendingButton && !recording : true;
  }, [asyncAudioEnabled, recording, showSendingButton]);
  var micPositionX = (0, _reactNativeReanimated.useSharedValue)(0);
  var micPositionY = (0, _reactNativeReanimated.useSharedValue)(0);
  var X_AXIS_POSITION = -asyncMessagesSlideToCancelDistance;
  var Y_AXIS_POSITION = -asyncMessagesLockDistance;
  var resetAudioRecording = function () {
    var _ref = (0, _asyncToGenerator2.default)(function* () {
      yield deleteVoiceRecording();
    });
    return function resetAudioRecording() {
      return _ref.apply(this, arguments);
    };
  }();
  var micLockHandler = function micLockHandler() {
    setMicLocked(true);
    _native.NativeHandlers.triggerHaptic('impactMedium');
  };
  var panGestureMic = _reactNativeGestureHandler.Gesture.Pan().activateAfterLongPress(asyncMessagesMinimumPressDuration + 100).onChange(function (event) {
    var newPositionX = event.translationX;
    var newPositionY = event.translationY;
    if (newPositionX <= 0 && newPositionX >= X_AXIS_POSITION) {
      micPositionX.value = newPositionX;
    }
    if (newPositionY <= 0 && newPositionY >= Y_AXIS_POSITION) {
      micPositionY.value = newPositionY;
    }
  }).onEnd(function () {
    var belowThresholdY = micPositionY.value > Y_AXIS_POSITION / 2;
    var belowThresholdX = micPositionX.value > X_AXIS_POSITION / 2;
    if (belowThresholdY && belowThresholdX) {
      micPositionY.value = (0, _reactNativeReanimated.withSpring)(0);
      micPositionX.value = (0, _reactNativeReanimated.withSpring)(0);
      if (recordingStatus === 'recording') {
        (0, _reactNativeReanimated.runOnJS)(uploadVoiceRecording)(asyncMessagesMultiSendEnabled);
      }
      return;
    }
    if (!belowThresholdY) {
      micPositionY.value = (0, _reactNativeReanimated.withSpring)(Y_AXIS_POSITION);
      (0, _reactNativeReanimated.runOnJS)(micLockHandler)();
    }
    if (!belowThresholdX) {
      micPositionX.value = (0, _reactNativeReanimated.withSpring)(X_AXIS_POSITION);
      (0, _reactNativeReanimated.runOnJS)(resetAudioRecording)();
    }
    micPositionX.value = 0;
    micPositionY.value = 0;
  }).onStart(function () {
    micPositionX.value = 0;
    micPositionY.value = 0;
    (0, _reactNativeReanimated.runOnJS)(setMicLocked)(false);
  });
  var lockIndicatorAnimatedStyle = (0, _reactNativeReanimated.useAnimatedStyle)(function () {
    return {
      transform: [{
        translateY: (0, _reactNativeReanimated.interpolate)(micPositionY.value, [0, Y_AXIS_POSITION], [0, Y_AXIS_POSITION], _reactNativeReanimated.Extrapolation.CLAMP)
      }]
    };
  });
  var micButttonAnimatedStyle = (0, _reactNativeReanimated.useAnimatedStyle)(function () {
    return {
      opacity: (0, _reactNativeReanimated.interpolate)(micPositionX.value, [0, X_AXIS_POSITION], [1, 0], _reactNativeReanimated.Extrapolation.CLAMP),
      transform: [{
        translateX: micPositionX.value
      }, {
        translateY: micPositionY.value
      }]
    };
  });
  var slideToCancelAnimatedStyle = (0, _reactNativeReanimated.useAnimatedStyle)(function () {
    return {
      opacity: (0, _reactNativeReanimated.interpolate)(micPositionX.value, [0, X_AXIS_POSITION], [1, 0], _reactNativeReanimated.Extrapolation.CLAMP),
      transform: [{
        translateX: (0, _reactNativeReanimated.interpolate)(micPositionX.value, [0, X_AXIS_POSITION], [0, X_AXIS_POSITION / 2], _reactNativeReanimated.Extrapolation.CLAMP)
      }]
    };
  });
  var _useAIState = (0, _AITypingIndicatorView.useAIState)(channel),
    aiState = _useAIState.aiState;
  var stopGenerating = (0, _react.useCallback)(function () {
    return channel == null ? void 0 : channel.stopAIResponse();
  }, [channel]);
  var shouldDisplayStopAIGeneration = [_AITypingIndicatorView.AIStates.Thinking, _AITypingIndicatorView.AIStates.Generating].includes(aiState) && !!StopMessageStreamingButton;
  return (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [(0, _jsxRuntime.jsxs)(_reactNative.View, {
      onLayout: function onLayout(_ref2) {
        var newHeight = _ref2.nativeEvent.layout.height;
        return setHeight(newHeight);
      },
      style: [styles.container, {
        backgroundColor: white,
        borderColor: border
      }, container],
      children: [editing && (0, _jsxRuntime.jsx)(InputEditingStateHeader, {}), quotedMessage && !editing && (0, _jsxRuntime.jsx)(InputReplyStateHeader, {}), recording && (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
        children: [(0, _jsxRuntime.jsx)(AudioRecordingLockIndicator, {
          messageInputHeight: height,
          micLocked: micLocked,
          style: lockIndicatorAnimatedStyle
        }), recordingStatus === 'stopped' ? (0, _jsxRuntime.jsx)(AudioRecordingPreview, {
          onVoicePlayerPlayPause: onVoicePlayerPlayPause,
          paused: paused,
          position: position,
          progress: progress,
          waveformData: waveformData
        }) : micLocked ? (0, _jsxRuntime.jsx)(AudioRecordingInProgress, {
          recordingDuration: recordingDuration,
          waveformData: waveformData
        }) : null]
      }), (0, _jsxRuntime.jsx)(_reactNative.View, {
        style: [styles.composerContainer, composerContainer],
        children: Input ? (0, _jsxRuntime.jsx)(Input, {
          additionalTextInputProps: additionalTextInputProps,
          getUsers: getUsers
        }) : (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
          children: [recording ? (0, _jsxRuntime.jsx)(AudioRecorder, {
            deleteVoiceRecording: deleteVoiceRecording,
            micLocked: micLocked,
            recording: recording,
            recordingDuration: recordingDuration,
            recordingStopped: recordingStatus === 'stopped',
            slideToCancelStyle: slideToCancelAnimatedStyle,
            stopVoiceRecording: stopVoiceRecording,
            uploadVoiceRecording: uploadVoiceRecording
          }) : (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
            children: [(0, _jsxRuntime.jsx)(_reactNative.View, {
              style: [styles.optionsContainer, optionsContainer],
              children: InputButtons && (0, _jsxRuntime.jsx)(InputButtons, {})
            }), (0, _jsxRuntime.jsxs)(_reactNative.View, {
              style: [styles.inputBoxContainer, {
                borderColor: grey_whisper,
                paddingVertical: command ? 8 : 12
              }, inputBoxContainer, isFocused ? focusedInputBoxContainer : null],
              children: [quotedMessage && (0, _jsxRuntime.jsx)(_reactNative.View, {
                style: [styles.replyContainer, replyContainer],
                children: (0, _jsxRuntime.jsx)(Reply, {})
              }), (0, _jsxRuntime.jsx)(AttachmentUploadPreviewList, {}), command ? (0, _jsxRuntime.jsx)(CommandInput, {
                disabled: !isOnline
              }) : (0, _jsxRuntime.jsx)(_reactNative.View, {
                style: [styles.autoCompleteInputContainer, autoCompleteInputContainer],
                children: (0, _jsxRuntime.jsx)(_AutoCompleteInput.AutoCompleteInput, Object.assign({
                  cooldownActive: !!cooldownRemainingSeconds
                }, additionalTextInputProps))
              })]
            })]
          }), shouldDisplayStopAIGeneration ? (0, _jsxRuntime.jsx)(StopMessageStreamingButton, {
            onPress: stopGenerating
          }) : isSendingButtonVisible ? cooldownRemainingSeconds ? (0, _jsxRuntime.jsx)(CooldownTimer, {
            seconds: cooldownRemainingSeconds
          }) : (0, _jsxRuntime.jsx)(_reactNative.View, {
            style: [styles.sendButtonContainer, sendButtonContainer],
            children: (0, _jsxRuntime.jsx)(SendButton, {
              disabled: !hasSendableData || !!command && !isOnline
            })
          }) : null, audioRecordingEnabled && (0, _native.isAudioRecorderAvailable)() && !micLocked && (0, _jsxRuntime.jsx)(_reactNativeGestureHandler.GestureDetector, {
            gesture: panGestureMic,
            children: (0, _jsxRuntime.jsx)(_reactNativeReanimated.default.View, {
              style: [styles.micButtonContainer, micButttonAnimatedStyle, micButtonContainer],
              children: (0, _jsxRuntime.jsx)(StartAudioRecordingButton, {
                permissionsGranted: permissionsGranted,
                recording: recording,
                startVoiceRecording: startVoiceRecording
              })
            })
          })]
        })
      }), (0, _jsxRuntime.jsx)(ShowThreadMessageInChannelButton, {
        threadList: threadList
      })]
    }), (0, _jsxRuntime.jsx)(_reactNative.View, {
      style: [styles.suggestionsListContainer, {
        bottom: height
      }, suggestionListContainer],
      children: (0, _jsxRuntime.jsx)(AutoCompleteSuggestionList, {})
    }), (0, _native.isImageMediaLibraryAvailable)() && selectedPicker ? (0, _jsxRuntime.jsx)(_reactNative.View, {
      style: [{
        backgroundColor: white_smoke,
        height: attachmentPickerBottomSheetHeight + attachmentSelectionBarHeight - bottomInset
      }, attachmentSelectionBar],
      children: (0, _jsxRuntime.jsx)(AttachmentPickerSelectionBar, {})
    }) : null, showPollCreationDialog ? (0, _jsxRuntime.jsx)(_reactNative.View, {
      style: {
        alignItems: 'center',
        flex: 1,
        justifyContent: 'center'
      },
      children: (0, _jsxRuntime.jsx)(_reactNative.Modal, {
        animationType: "slide",
        onRequestClose: closePollCreationDialog,
        visible: showPollCreationDialog,
        children: (0, _jsxRuntime.jsx)(_reactNativeGestureHandler.GestureHandlerRootView, {
          style: {
            flex: 1
          },
          children: (0, _jsxRuntime.jsx)(_reactNative.SafeAreaView, {
            style: {
              backgroundColor: white,
              flex: 1
            },
            children: (0, _jsxRuntime.jsx)(_CreatePollContent.CreatePoll, {
              closePollCreationDialog: closePollCreationDialog,
              CreatePollContent: CreatePollContent,
              sendMessage: sendMessage
            })
          })
        })
      })
    }) : null]
  });
};
var areEqual = function areEqual(prevProps, nextProps) {
  var prevAdditionalTextInputProps = prevProps.additionalTextInputProps,
    prevAsyncMessagesLockDistance = prevProps.asyncMessagesLockDistance,
    prevAsyncMessagesMinimumPressDuration = prevProps.asyncMessagesMinimumPressDuration,
    prevAsyncMessagesSlideToCancelDistance = prevProps.asyncMessagesSlideToCancelDistance,
    prevAsyncMessagesEnabled = prevProps.audioRecordingEnabled,
    prevChannel = prevProps.channel,
    prevClosePollCreationDialog = prevProps.closePollCreationDialog,
    prevCooldownEndsAt = prevProps.cooldownEndsAt,
    prevEditing = prevProps.editing,
    prevIsOnline = prevProps.isOnline,
    prevOpenPollCreationDialog = prevProps.openPollCreationDialog,
    prevSelectedPicker = prevProps.selectedPicker,
    prevShowPollCreationDialog = prevProps.showPollCreationDialog,
    prevT = prevProps.t,
    prevThreadList = prevProps.threadList;
  var nextAdditionalTextInputProps = nextProps.additionalTextInputProps,
    nextAsyncMessagesLockDistance = nextProps.asyncMessagesLockDistance,
    nextAsyncMessagesMinimumPressDuration = nextProps.asyncMessagesMinimumPressDuration,
    nextAsyncMessagesSlideToCancelDistance = nextProps.asyncMessagesSlideToCancelDistance,
    nextAsyncMessagesEnabled = nextProps.audioRecordingEnabled,
    nextChannel = nextProps.channel,
    nextClosePollCreationDialog = nextProps.closePollCreationDialog,
    nextCooldownEndsAt = nextProps.cooldownEndsAt,
    nextEditing = nextProps.editing,
    nextIsOnline = nextProps.isOnline,
    nextOpenPollCreationDialog = nextProps.openPollCreationDialog,
    nextSelectedPicker = nextProps.selectedPicker,
    nextShowPollCreationDialog = nextProps.showPollCreationDialog,
    nextT = nextProps.t,
    nextThreadList = nextProps.threadList;
  var tEqual = prevT === nextT;
  if (!tEqual) {
    return false;
  }
  var pollCreationInputPropsEqual = prevOpenPollCreationDialog === nextOpenPollCreationDialog && prevClosePollCreationDialog === nextClosePollCreationDialog && prevShowPollCreationDialog === nextShowPollCreationDialog;
  if (!pollCreationInputPropsEqual) {
    return false;
  }
  var additionalTextInputPropsEven = prevAdditionalTextInputProps === nextAdditionalTextInputProps;
  if (!additionalTextInputPropsEven) {
    return false;
  }
  var asyncMessagesEnabledEqual = prevAsyncMessagesEnabled === nextAsyncMessagesEnabled;
  if (!asyncMessagesEnabledEqual) {
    return false;
  }
  var channelEqual = prevChannel.cid === nextChannel.cid;
  if (!channelEqual) {
    return false;
  }
  var asyncMessagesLockDistanceEqual = prevAsyncMessagesLockDistance === nextAsyncMessagesLockDistance;
  if (!asyncMessagesLockDistanceEqual) {
    return false;
  }
  var asyncMessagesMinimumPressDurationEqual = prevAsyncMessagesMinimumPressDuration === nextAsyncMessagesMinimumPressDuration;
  if (!asyncMessagesMinimumPressDurationEqual) {
    return false;
  }
  var asyncMessagesSlideToCancelDistanceEqual = prevAsyncMessagesSlideToCancelDistance === nextAsyncMessagesSlideToCancelDistance;
  if (!asyncMessagesSlideToCancelDistanceEqual) {
    return false;
  }
  var editingEqual = !!prevEditing === !!nextEditing;
  if (!editingEqual) {
    return false;
  }
  var isOnlineEqual = prevIsOnline === nextIsOnline;
  if (!isOnlineEqual) {
    return false;
  }
  var cooldownEndsAtEqual = prevCooldownEndsAt === nextCooldownEndsAt;
  if (!cooldownEndsAtEqual) {
    return false;
  }
  var threadListEqual = prevThreadList === nextThreadList;
  if (!threadListEqual) {
    return false;
  }
  var selectedPickerEqual = prevSelectedPicker === nextSelectedPicker;
  if (!selectedPickerEqual) {
    return false;
  }
  return true;
};
var MemoizedMessageInput = _react.default.memo(MessageInputWithContext, areEqual);
var MessageInput = exports.MessageInput = function MessageInput(props) {
  var _useChatContext = (0, _contexts.useChatContext)(),
    isOnline = _useChatContext.isOnline;
  var ownCapabilities = (0, _contexts.useOwnCapabilitiesContext)();
  var _useChannelContext = (0, _ChannelContext.useChannelContext)(),
    channel = _useChannelContext.channel,
    members = _useChannelContext.members,
    threadList = _useChannelContext.threadList,
    watchers = _useChannelContext.watchers;
  var _useMessageInputConte = (0, _MessageInputContext.useMessageInputContext)(),
    additionalTextInputProps = _useMessageInputConte.additionalTextInputProps,
    asyncMessagesLockDistance = _useMessageInputConte.asyncMessagesLockDistance,
    asyncMessagesMinimumPressDuration = _useMessageInputConte.asyncMessagesMinimumPressDuration,
    asyncMessagesMultiSendEnabled = _useMessageInputConte.asyncMessagesMultiSendEnabled,
    asyncMessagesSlideToCancelDistance = _useMessageInputConte.asyncMessagesSlideToCancelDistance,
    AttachmentPickerBottomSheetHandle = _useMessageInputConte.AttachmentPickerBottomSheetHandle,
    attachmentPickerBottomSheetHandleHeight = _useMessageInputConte.attachmentPickerBottomSheetHandleHeight,
    attachmentPickerBottomSheetHeight = _useMessageInputConte.attachmentPickerBottomSheetHeight,
    AttachmentPickerSelectionBar = _useMessageInputConte.AttachmentPickerSelectionBar,
    attachmentSelectionBarHeight = _useMessageInputConte.attachmentSelectionBarHeight,
    AttachmentUploadPreviewList = _useMessageInputConte.AttachmentUploadPreviewList,
    AudioRecorder = _useMessageInputConte.AudioRecorder,
    audioRecordingEnabled = _useMessageInputConte.audioRecordingEnabled,
    AudioRecordingInProgress = _useMessageInputConte.AudioRecordingInProgress,
    AudioRecordingLockIndicator = _useMessageInputConte.AudioRecordingLockIndicator,
    AudioRecordingPreview = _useMessageInputConte.AudioRecordingPreview,
    AudioRecordingWaveform = _useMessageInputConte.AudioRecordingWaveform,
    AutoCompleteSuggestionList = _useMessageInputConte.AutoCompleteSuggestionList,
    CameraSelectorIcon = _useMessageInputConte.CameraSelectorIcon,
    closeAttachmentPicker = _useMessageInputConte.closeAttachmentPicker,
    closePollCreationDialog = _useMessageInputConte.closePollCreationDialog,
    compressImageQuality = _useMessageInputConte.compressImageQuality,
    cooldownEndsAt = _useMessageInputConte.cooldownEndsAt,
    CooldownTimer = _useMessageInputConte.CooldownTimer,
    CreatePollContent = _useMessageInputConte.CreatePollContent,
    CreatePollIcon = _useMessageInputConte.CreatePollIcon,
    FileSelectorIcon = _useMessageInputConte.FileSelectorIcon,
    ImageSelectorIcon = _useMessageInputConte.ImageSelectorIcon,
    Input = _useMessageInputConte.Input,
    inputBoxRef = _useMessageInputConte.inputBoxRef,
    InputButtons = _useMessageInputConte.InputButtons,
    InputEditingStateHeader = _useMessageInputConte.InputEditingStateHeader,
    CommandInput = _useMessageInputConte.CommandInput,
    InputReplyStateHeader = _useMessageInputConte.InputReplyStateHeader,
    openPollCreationDialog = _useMessageInputConte.openPollCreationDialog,
    SendButton = _useMessageInputConte.SendButton,
    sendMessage = _useMessageInputConte.sendMessage,
    SendMessageDisallowedIndicator = _useMessageInputConte.SendMessageDisallowedIndicator,
    showPollCreationDialog = _useMessageInputConte.showPollCreationDialog,
    ShowThreadMessageInChannelButton = _useMessageInputConte.ShowThreadMessageInChannelButton,
    StartAudioRecordingButton = _useMessageInputConte.StartAudioRecordingButton,
    StopMessageStreamingButton = _useMessageInputConte.StopMessageStreamingButton,
    uploadNewFile = _useMessageInputConte.uploadNewFile,
    VideoRecorderSelectorIcon = _useMessageInputConte.VideoRecorderSelectorIcon;
  var _useAttachmentPickerC = (0, _AttachmentPickerContext.useAttachmentPickerContext)(),
    bottomInset = _useAttachmentPickerC.bottomInset,
    bottomSheetRef = _useAttachmentPickerC.bottomSheetRef,
    selectedPicker = _useAttachmentPickerC.selectedPicker;
  var messageComposer = (0, _useMessageComposer.useMessageComposer)();
  var editing = !!messageComposer.editedMessage;
  var _useMessageComposerAP = (0, _MessageComposerAPIContext.useMessageComposerAPIContext)(),
    clearEditingState = _useMessageComposerAP.clearEditingState;
  var _useMessagesContext = (0, _MessagesContext.useMessagesContext)(),
    Reply = _useMessagesContext.Reply;
  var _useTranslationContex = (0, _TranslationContext.useTranslationContext)(),
    t = _useTranslationContex.t;
  if (!ownCapabilities.sendMessage && !editing && SendMessageDisallowedIndicator) {
    return (0, _jsxRuntime.jsx)(SendMessageDisallowedIndicator, {});
  }
  return (0, _jsxRuntime.jsx)(MemoizedMessageInput, Object.assign({
    additionalTextInputProps: additionalTextInputProps,
    asyncMessagesLockDistance: asyncMessagesLockDistance,
    asyncMessagesMinimumPressDuration: asyncMessagesMinimumPressDuration,
    asyncMessagesMultiSendEnabled: asyncMessagesMultiSendEnabled,
    asyncMessagesSlideToCancelDistance: asyncMessagesSlideToCancelDistance,
    AttachmentPickerBottomSheetHandle: AttachmentPickerBottomSheetHandle,
    attachmentPickerBottomSheetHandleHeight: attachmentPickerBottomSheetHandleHeight,
    attachmentPickerBottomSheetHeight: attachmentPickerBottomSheetHeight,
    AttachmentPickerSelectionBar: AttachmentPickerSelectionBar,
    attachmentSelectionBarHeight: attachmentSelectionBarHeight,
    AttachmentUploadPreviewList: AttachmentUploadPreviewList,
    AudioRecorder: AudioRecorder,
    audioRecordingEnabled: audioRecordingEnabled,
    AudioRecordingInProgress: AudioRecordingInProgress,
    AudioRecordingLockIndicator: AudioRecordingLockIndicator,
    AudioRecordingPreview: AudioRecordingPreview,
    AudioRecordingWaveform: AudioRecordingWaveform,
    AutoCompleteSuggestionList: AutoCompleteSuggestionList,
    bottomInset: bottomInset,
    bottomSheetRef: bottomSheetRef,
    CameraSelectorIcon: CameraSelectorIcon,
    channel: channel,
    clearEditingState: clearEditingState,
    closeAttachmentPicker: closeAttachmentPicker,
    closePollCreationDialog: closePollCreationDialog,
    CommandInput: CommandInput,
    compressImageQuality: compressImageQuality,
    cooldownEndsAt: cooldownEndsAt,
    CooldownTimer: CooldownTimer,
    CreatePollContent: CreatePollContent,
    CreatePollIcon: CreatePollIcon,
    editing: editing,
    FileSelectorIcon: FileSelectorIcon,
    ImageSelectorIcon: ImageSelectorIcon,
    Input: Input,
    inputBoxRef: inputBoxRef,
    InputButtons: InputButtons,
    InputEditingStateHeader: InputEditingStateHeader,
    InputReplyStateHeader: InputReplyStateHeader,
    isOnline: isOnline,
    members: members,
    openPollCreationDialog: openPollCreationDialog,
    Reply: Reply,
    selectedPicker: selectedPicker,
    SendButton: SendButton,
    sendMessage: sendMessage,
    SendMessageDisallowedIndicator: SendMessageDisallowedIndicator,
    showPollCreationDialog: showPollCreationDialog,
    ShowThreadMessageInChannelButton: ShowThreadMessageInChannelButton,
    StartAudioRecordingButton: StartAudioRecordingButton,
    StopMessageStreamingButton: StopMessageStreamingButton,
    t: t,
    threadList: threadList,
    uploadNewFile: uploadNewFile,
    VideoRecorderSelectorIcon: VideoRecorderSelectorIcon,
    watchers: watchers
  }, props));
};
MessageInput.displayName = 'MessageInput{messageInput}';
//# sourceMappingURL=MessageInput.js.map