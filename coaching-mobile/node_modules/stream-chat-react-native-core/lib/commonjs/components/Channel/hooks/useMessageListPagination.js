var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMessageListPagination = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _react = require("react");
var _debounce = _interopRequireDefault(require("lodash/debounce"));
var _useChannelDataState = require("./useChannelDataState");
var _hooks = require("../../../hooks");
var _utils = require("../../../utils/utils");
var defaultDebounceInterval = 500;
var debounceOptions = {
  leading: true,
  trailing: true
};
var useMessageListPagination = exports.useMessageListPagination = function useMessageListPagination(_ref) {
  var channel = _ref.channel;
  var _useChannelMessageDat = (0, _useChannelDataState.useChannelMessageDataState)(channel),
    copyMessagesStateFromChannel = _useChannelMessageDat.copyMessagesStateFromChannel,
    jumpToLatestMessage = _useChannelMessageDat.jumpToLatestMessage,
    jumpToMessageFinished = _useChannelMessageDat.jumpToMessageFinished,
    loadInitialMessagesStateFromChannel = _useChannelMessageDat.loadInitialMessagesStateFromChannel,
    loadMoreFinishedFn = _useChannelMessageDat.loadMoreFinished,
    loadMoreRecentFinishedFn = _useChannelMessageDat.loadMoreRecentFinished,
    setLoading = _useChannelMessageDat.setLoading,
    setLoadingMore = _useChannelMessageDat.setLoadingMore,
    setLoadingMoreRecent = _useChannelMessageDat.setLoadingMoreRecent,
    state = _useChannelMessageDat.state;
  var loadMoreFinished = (0, _react.useRef)((0, _debounce.default)(function (hasMore, messages) {
    loadMoreFinishedFn(hasMore, messages);
  }, defaultDebounceInterval, debounceOptions)).current;
  var loadMoreRecentFinished = (0, _react.useRef)((0, _debounce.default)(function (hasMore, newMessages) {
    loadMoreRecentFinishedFn(hasMore, newMessages);
  }, defaultDebounceInterval, debounceOptions)).current;
  var loadLatestMessages = (0, _hooks.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    try {
      setLoading(true);
      yield channel.state.loadMessageIntoState('latest');
      loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
      jumpToLatestMessage();
    } catch (err) {
      console.warn('Loading latest messages failed with error:', err);
    }
  }));
  var loadMore = (0, _hooks.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    var _state$messages;
    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;
    if (!channel.state.messagePagination.hasPrev) {
      return;
    }
    if (state.loadingMore || state.loadingMoreRecent) {
      return;
    }
    setLoadingMore(true);
    var oldestMessage = (_state$messages = state.messages) == null ? void 0 : _state$messages[0];
    var oldestID = oldestMessage == null ? void 0 : oldestMessage.id;
    try {
      yield channel.query({
        messages: {
          id_lt: oldestID,
          limit: limit
        },
        watchers: {
          limit: limit
        }
      });
      loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
      setLoadingMore(false);
    } catch (e) {
      setLoadingMore(false);
      console.warn('Message pagination(fetching old messages) request failed with error:', e);
    }
  }));
  var loadMoreRecent = (0, _hooks.useStableCallback)((0, _asyncToGenerator2.default)(function* () {
    var _state$messages2;
    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    if (!channel.state.messagePagination.hasNext) {
      return;
    }
    if (state.loadingMore || state.loadingMoreRecent) {
      return;
    }
    setLoadingMoreRecent(true);
    var newestMessage = (_state$messages2 = state.messages) == null ? void 0 : _state$messages2[(state == null ? void 0 : state.messages.length) - 1];
    var newestID = newestMessage == null ? void 0 : newestMessage.id;
    try {
      yield channel.query({
        messages: {
          id_gt: newestID,
          limit: limit
        },
        watchers: {
          limit: limit
        }
      });
      loadMoreRecentFinished(channel.state.messagePagination.hasNext, channel.state.messages);
    } catch (e) {
      setLoadingMoreRecent(false);
      console.warn('Message pagination(fetching new messages) request failed with error:', e);
      return;
    }
  }));
  var loadChannelAroundMessage = (0, _hooks.useStableCallback)(function () {
    var _ref6 = (0, _asyncToGenerator2.default)(function* (_ref5) {
      var _ref5$limit = _ref5.limit,
        limit = _ref5$limit === void 0 ? 25 : _ref5$limit,
        messageIdToLoadAround = _ref5.messageId,
        setTargetedMessage = _ref5.setTargetedMessage;
      if (!messageIdToLoadAround) {
        return;
      }
      setLoadingMore(true);
      setLoading(true);
      try {
        yield channel.state.loadMessageIntoState(messageIdToLoadAround, undefined, limit);
        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
        jumpToMessageFinished(channel.state.messagePagination.hasNext, messageIdToLoadAround);
        if (setTargetedMessage) {
          setTargetedMessage(messageIdToLoadAround);
        }
      } catch (error) {
        setLoadingMore(false);
        setLoading(false);
        console.warn('Message pagination(fetching messages in the channel around a message id) request failed with error:', error);
        return;
      }
    });
    return function (_x) {
      return _ref6.apply(this, arguments);
    };
  }());
  var fetchMessagesAround = (0, _hooks.useStableCallback)(function () {
    var _ref7 = (0, _asyncToGenerator2.default)(function* (channel, timestamp, limit) {
      try {
        var _yield$channel$query = yield channel.query({
            messages: {
              created_at_around: timestamp,
              limit: limit
            }
          }, 'new'),
          messages = _yield$channel$query.messages;
        return messages;
      } catch (error) {
        console.error('Error fetching messages around timestamp:', error);
        throw error;
      }
    });
    return function (_x2, _x3, _x4) {
      return _ref7.apply(this, arguments);
    };
  }());
  var loadChannelAtFirstUnreadMessage = (0, _hooks.useStableCallback)(function () {
    var _ref9 = (0, _asyncToGenerator2.default)(function* (_ref8) {
      var channelUnreadState = _ref8.channelUnreadState,
        _ref8$limit = _ref8.limit,
        limit = _ref8$limit === void 0 ? 25 : _ref8$limit,
        setChannelUnreadState = _ref8.setChannelUnreadState,
        setTargetedMessage = _ref8.setTargetedMessage;
      try {
        if (!(channelUnreadState != null && channelUnreadState.unread_messages)) {
          return;
        }
        var first_unread_message_id = channelUnreadState.first_unread_message_id,
          last_read = channelUnreadState.last_read,
          last_read_message_id = channelUnreadState.last_read_message_id;
        var firstUnreadMessageId = first_unread_message_id;
        var lastReadMessageId = last_read_message_id;
        var isInCurrentMessageSet = false;
        var messagesState = channel.state.messages;
        if (firstUnreadMessageId) {
          var messageIdx = (0, _utils.findInMessagesById)(messagesState, firstUnreadMessageId);
          isInCurrentMessageSet = messageIdx !== -1;
        } else if (lastReadMessageId) {
          var _messagesState;
          var _messageIdx = (0, _utils.findInMessagesById)(messagesState, lastReadMessageId);
          isInCurrentMessageSet = _messageIdx !== -1;
          firstUnreadMessageId = _messageIdx > -1 ? (_messagesState = messagesState[_messageIdx + 1]) == null ? void 0 : _messagesState.id : undefined;
        } else {
          var lastReadTimestamp = last_read.getTime();
          var _findInMessagesByDate = (0, _utils.findInMessagesByDate)(messagesState, last_read),
            lastReadIdx = _findInMessagesByDate.index,
            lastReadMessage = _findInMessagesByDate.message;
          if (lastReadMessage) {
            lastReadMessageId = lastReadMessage.id;
            firstUnreadMessageId = messagesState[lastReadIdx + 1].id;
            isInCurrentMessageSet = !!firstUnreadMessageId;
          } else {
            setLoadingMore(true);
            setLoading(true);
            var messages;
            try {
              messages = yield fetchMessagesAround(channel, last_read.toISOString(), limit);
            } catch (error) {
              setLoading(false);
              loadMoreFinished(channel.state.messagePagination.hasPrev, messagesState);
              console.log('Loading channel at first unread message failed with error:', error);
              return;
            }
            var firstMessageWithCreationDate = messages.find(function (msg) {
              return msg.created_at;
            });
            if (!firstMessageWithCreationDate) {
              loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
              throw new Error('Failed to jump to first unread message id.');
            }
            var firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();
            if (lastReadTimestamp < firstMessageTimestamp) {
              firstUnreadMessageId = firstMessageWithCreationDate.id;
            } else {
              var _result$message;
              var result = (0, _utils.findInMessagesByDate)(messages, last_read);
              lastReadMessageId = (_result$message = result.message) == null ? void 0 : _result$message.id;
            }
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
          }
        }
        if (!firstUnreadMessageId && !lastReadMessageId) {
          throw new Error('Failed to jump to first unread message id.');
        }
        if (!isInCurrentMessageSet) {
          try {
            setLoadingMore(true);
            setLoading(true);
            var targetedMessage = firstUnreadMessageId || lastReadMessageId;
            yield channel.state.loadMessageIntoState(targetedMessage, undefined, limit);
            var indexOfTarget = channel.state.messages.findIndex(function (message) {
              return message.id === targetedMessage;
            });
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            firstUnreadMessageId = firstUnreadMessageId != null ? firstUnreadMessageId : channel.state.messages[indexOfTarget + 1].id;
          } catch (error) {
            setLoading(false);
            loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);
            console.log('Loading channel at first unread message failed with error:', error);
            return;
          }
        }
        if (!firstUnreadMessageId) {
          throw new Error('Failed to jump to first unread message id.');
        }
        if (!first_unread_message_id && setChannelUnreadState) {
          setChannelUnreadState(Object.assign({}, channelUnreadState, {
            first_unread_message_id: firstUnreadMessageId,
            last_read_message_id: lastReadMessageId
          }));
        }
        jumpToMessageFinished(channel.state.messagePagination.hasNext, firstUnreadMessageId);
        if (setTargetedMessage) {
          setTargetedMessage(firstUnreadMessageId);
        }
      } catch (error) {
        console.log('Loading channel at first unread message failed with error:', error);
      }
    });
    return function (_x5) {
      return _ref9.apply(this, arguments);
    };
  }());
  return {
    copyMessagesStateFromChannel: copyMessagesStateFromChannel,
    loadChannelAroundMessage: loadChannelAroundMessage,
    loadChannelAtFirstUnreadMessage: loadChannelAtFirstUnreadMessage,
    loadInitialMessagesStateFromChannel: loadInitialMessagesStateFromChannel,
    loadLatestMessages: loadLatestMessages,
    loadMore: loadMore,
    loadMoreRecent: loadMoreRecent,
    state: state
  };
};
//# sourceMappingURL=useMessageListPagination.js.map