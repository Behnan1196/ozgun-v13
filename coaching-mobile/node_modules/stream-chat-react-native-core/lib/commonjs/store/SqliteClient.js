var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SqliteClient = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _constants = require("./constants");
var _schema = require("./schema");
var _createCreateTableQuery = require("./sqlite-utils/createCreateTableQuery");
var _SqliteClient;
var sqlite;
try {
  sqlite = require('@op-engineering/op-sqlite');
} catch (e) {
  var isRemoteDebuggerError = e instanceof Error && e.message.includes('Failed to install');
  if (isRemoteDebuggerError) {
    throw e;
  }
}
var SqliteClient = exports.SqliteClient = (0, _createClass2.default)(function SqliteClient() {
  (0, _classCallCheck2.default)(this, SqliteClient);
});
_SqliteClient = SqliteClient;
SqliteClient.dbVersion = 11;
SqliteClient.dbName = _constants.DB_NAME;
SqliteClient.dbLocation = _constants.DB_LOCATION;
SqliteClient.getDbVersion = function () {
  return _SqliteClient.dbVersion;
};
SqliteClient.setDbVersion = function (version) {
  return _SqliteClient.dbVersion = version;
};
SqliteClient.openDB = (0, _asyncToGenerator2.default)(function* () {
  try {
    var _SqliteClient$db;
    if (sqlite === undefined) {
      throw new Error('Please install "@op-engineering/op-sqlite" package to enable offline support');
    }
    _SqliteClient.db = sqlite.open({
      location: _SqliteClient.dbLocation,
      name: _SqliteClient.dbName
    });
    yield (_SqliteClient$db = _SqliteClient.db) == null ? void 0 : _SqliteClient$db.execute('PRAGMA foreign_keys = ON', []);
  } catch (e) {
    _SqliteClient.logger == null || _SqliteClient.logger('error', `Error opening database ${_SqliteClient.dbName}`, {
      error: e
    });
    console.error(`Error opening database ${_SqliteClient.dbName}: ${e}`);
  }
});
SqliteClient.closeDB = function () {
  try {
    if (!_SqliteClient.db) {
      throw new Error('DB is not open or initialized.');
    }
    _SqliteClient.db.close();
    _SqliteClient.db = undefined;
  } catch (e) {
    _SqliteClient.logger == null || _SqliteClient.logger('error', `Error closing database ${_SqliteClient.dbName}`, {
      error: e
    });
    console.error(`Error closing database ${_SqliteClient.dbName}: ${e}`);
  }
};
SqliteClient.executeSqlBatch = function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* (queries) {
    if (!queries || !queries.length) {
      return;
    }
    try {
      if (!_SqliteClient.db) {
        throw new Error('DB is not open or initialized.');
      }
      var finalQueries = queries.map(function (query) {
        if (query.length === 1) {
          query.push([]);
        }
        return query;
      });
      yield _SqliteClient.db.executeBatch(finalQueries);
    } catch (e) {
      var _SqliteClient$db2;
      (_SqliteClient$db2 = _SqliteClient.db) == null || _SqliteClient$db2.execute('ROLLBACK');
      _SqliteClient.logger == null || _SqliteClient.logger('error', 'SqlBatch queries failed', {
        error: e,
        queries: queries
      });
      throw new Error(`Queries failed: ${e}`);
    }
  });
  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
SqliteClient.executeSql = function () {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (query, params) {
    try {
      if (!_SqliteClient.db) {
        throw new Error('DB is not open or initialized.');
      }
      var _yield$_SqliteClient$ = yield _SqliteClient.db.execute(query, params),
        rows = _yield$_SqliteClient$.rows;
      return rows ? rows : [];
    } catch (e) {
      _SqliteClient.logger == null || _SqliteClient.logger('error', 'Sql single query failed', {
        error: e,
        query: query
      });
      throw new Error(`Query failed: ${e}: `);
    }
  });
  return function (_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
SqliteClient.dropTables = (0, _asyncToGenerator2.default)(function* () {
  var queries = Object.keys(_schema.tables).map(function (table) {
    return [`DROP TABLE IF EXISTS ${table}`, []];
  });
  _SqliteClient.logger == null || _SqliteClient.logger('info', 'Dropping tables', {
    tables: Object.keys(_schema.tables)
  });
  yield _SqliteClient.executeSqlBatch(queries);
});
SqliteClient.deleteDatabase = function () {
  _SqliteClient.logger == null || _SqliteClient.logger('info', 'deleteDatabase', {
    dbLocation: _SqliteClient.dbLocation,
    dbname: _SqliteClient.dbName
  });
  try {
    if (!_SqliteClient.db) {
      throw new Error('DB is not open or initialized.');
    }
    _SqliteClient.db.delete();
  } catch (e) {
    _SqliteClient.logger == null || _SqliteClient.logger('error', 'Error deleting DB', {
      dbLocation: _SqliteClient.dbLocation,
      dbname: _SqliteClient.dbName,
      error: e
    });
    throw new Error(`Error deleting DB: ${e}`);
  }
  return true;
};
SqliteClient.initializeDatabase = (0, _asyncToGenerator2.default)(function* () {
  try {
    yield _SqliteClient.openDB();
    var version = yield _SqliteClient.getUserPragmaVersion();
    if (version !== _SqliteClient.dbVersion) {
      _SqliteClient.logger == null || _SqliteClient.logger('info', 'DB version mismatch');
      yield _SqliteClient.dropTables();
      yield _SqliteClient.updateUserPragmaVersion(_SqliteClient.dbVersion);
    }
    _SqliteClient.logger == null || _SqliteClient.logger('info', 'create tables if not exists', {
      tables: Object.keys(_schema.tables)
    });
    var q = Object.keys(_schema.tables).reduce(function (queriesSoFar, tableName) {
      queriesSoFar.push.apply(queriesSoFar, (0, _toConsumableArray2.default)((0, _createCreateTableQuery.createCreateTableQuery)(tableName)));
      return queriesSoFar;
    }, []);
    yield _SqliteClient.executeSqlBatch(q);
    return true;
  } catch (e) {
    console.log('Error initializing DB', e);
    _SqliteClient.logger == null || _SqliteClient.logger('error', 'Error initializing DB', {
      dbLocation: _SqliteClient.dbLocation,
      dbname: _SqliteClient.dbName,
      error: e
    });
    return false;
  }
});
SqliteClient.updateUserPragmaVersion = function () {
  var _ref6 = (0, _asyncToGenerator2.default)(function* (version) {
    _SqliteClient.logger == null || _SqliteClient.logger('info', `updateUserPragmaVersion to ${version}`);
    if (!_SqliteClient.db) {
      throw new Error('DB is not open or initialized.');
    }
    yield _SqliteClient.db.execute(`PRAGMA user_version = ${version}`, []);
  });
  return function (_x4) {
    return _ref6.apply(this, arguments);
  };
}();
SqliteClient.getUserPragmaVersion = (0, _asyncToGenerator2.default)(function* () {
  try {
    if (!_SqliteClient.db) {
      throw new Error('DB is not open or initialized.');
    }
    var _yield$_SqliteClient$2 = yield _SqliteClient.db.execute('PRAGMA user_version', []),
      rows = _yield$_SqliteClient$2.rows;
    var result = rows ? rows : [];
    _SqliteClient.logger == null || _SqliteClient.logger('info', 'getUserPragmaVersion', {
      result: result
    });
    return result[0].user_version;
  } catch (e) {
    console.log('Error getting user_version', e);
    throw new Error(`Querying for user_version failed: ${e}`);
  }
});
SqliteClient.resetDB = (0, _asyncToGenerator2.default)(function* () {
  _SqliteClient.logger == null || _SqliteClient.logger('info', 'resetDB');
  if (_SqliteClient.db) {
    yield _SqliteClient.dropTables();
    _SqliteClient.closeDB();
  }
  yield _SqliteClient.initializeDatabase();
});
//# sourceMappingURL=SqliteClient.js.map