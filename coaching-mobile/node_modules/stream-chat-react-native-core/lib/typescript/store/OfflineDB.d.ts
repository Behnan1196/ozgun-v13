import { AbstractOfflineDB, StreamChat } from 'stream-chat';
import type { DBGetAppSettingsType, DBGetChannelsForQueryType, DBGetChannelsType, DBGetLastSyncedAtType, DBUpsertAppSettingsType, DBUpsertUserSyncStatusType } from 'stream-chat';
export declare class OfflineDB extends AbstractOfflineDB {
    constructor({ client }: {
        client: StreamChat;
    });
    upsertCidsForQuery: ({ cids, filters, execute, sort, }: {
        cids: string[];
        filters?: import("stream-chat").ChannelFilters;
        execute?: boolean;
        sort?: import("stream-chat").ChannelSort;
    }) => Promise<import("./types").PreparedQueries[]>;
    upsertChannels: ({ channels, execute, isLatestMessagesSet, }: {
        channels: import("stream-chat").ChannelAPIResponse[];
        execute?: boolean;
        isLatestMessagesSet?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    upsertUserSyncStatus: ({ userId, lastSyncedAt, execute }: DBUpsertUserSyncStatusType) => Promise<import("./types").PreparedQueries[]>;
    upsertAppSettings: ({ appSettings, userId, execute }: DBUpsertAppSettingsType) => Promise<import("./types").PreparedQueries[]>;
    upsertPoll: ({ execute, poll, }: {
        poll: import("stream-chat").PollResponse;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    upsertDraft: ({ execute, draft, }: {
        draft: import("stream-chat").DraftResponse;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    getDraft: ({ cid, userId, parent_id, }: {
        cid: string;
        userId: string;
        parent_id?: string;
    }) => Promise<import("stream-chat").DraftResponse | null>;
    deleteDraft: ({ cid, parent_id, execute, }: {
        cid: string;
        parent_id?: string;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    upsertChannelData: ({ channel, execute, }: {
        channel: import("stream-chat").ChannelResponse;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    upsertReads: ({ cid, execute, reads, }: {
        cid: string;
        reads: import("stream-chat").ReadResponse[];
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    upsertMessages: ({ execute, messages, }: {
        messages: (import("stream-chat").MessageResponse | import("stream-chat").LocalMessage)[];
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    upsertMembers: ({ cid, execute, members, }: {
        cid: string;
        members: import("stream-chat").ChannelMemberResponse[];
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    updateMessage: ({ execute, message, }: {
        message: import("stream-chat").MessageResponse | import("stream-chat").LocalMessage;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    getChannels: ({ cids, userId }: DBGetChannelsType) => Promise<Omit<import("stream-chat").ChannelAPIResponse, "duration">[]>;
    getChannelsForQuery: ({ userId, filters, sort }: DBGetChannelsForQueryType) => Promise<Omit<import("stream-chat").ChannelAPIResponse, "duration">[] | null>;
    getAllChannelCids: () => Promise<string[]>;
    getLastSyncedAt: ({ userId }: DBGetLastSyncedAtType) => Promise<string | undefined>;
    getAppSettings: ({ userId }: DBGetAppSettingsType) => Promise<import("stream-chat").AppSettingsAPIResponse | null>;
    getReactions: ({ messageId, filters, sort, limit, }: {
        messageId: string;
        filters?: Pick<import("stream-chat").ReactionFilters, "type">;
        sort?: import("stream-chat").ReactionSort;
        limit?: number;
    }) => Promise<import("stream-chat").ReactionResponse[] | null>;
    addPendingTask: (task: import("stream-chat").PendingTask) => Promise<() => Promise<void>>;
    deletePendingTask: ({ id }: {
        id: number;
    }) => Promise<import("./types").PreparedQueries[]>;
    deleteReaction: ({ execute, message, reaction, }: {
        reaction: import("stream-chat").ReactionResponse;
        message?: import("stream-chat").MessageResponse | import("stream-chat").FormatMessageResponse;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    deleteMember: ({ cid, execute, member, }: {
        cid: string;
        member: import("stream-chat").ChannelMemberResponse;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    deleteChannel: ({ cid, execute, }: {
        cid: string;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    deleteMessagesForChannel: ({ cid, truncated_at, execute, }: {
        cid: string;
        truncated_at?: string;
        execute?: boolean;
    }) => Promise<[string, (string | number)[]][]>;
    dropPendingTasks: ({ messageId, execute, }: {
        messageId: string;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    hardDeleteMessage: ({ execute, id }: {
        id: string;
        execute?: boolean;
    }) => Promise<([string] | [string, any[]])[]>;
    softDeleteMessage: ({ execute, id, }: {
        id: string;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    getPendingTasks: (conditions?: {
        messageId?: string;
    }) => Promise<import("stream-chat").PendingTask[]>;
    updateReaction: ({ execute, message, reaction, }: {
        message: import("stream-chat").MessageResponse | import("stream-chat").LocalMessage;
        reaction: import("stream-chat").ReactionResponse;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    insertReaction: ({ execute, message, reaction, }: {
        message: import("stream-chat").MessageResponse | import("stream-chat").LocalMessage;
        reaction: import("stream-chat").ReactionResponse;
        execute?: boolean;
    }) => Promise<import("./types").PreparedQueries[]>;
    channelExists: ({ cid }: {
        cid: string;
    }) => Promise<boolean>;
    resetDB: () => Promise<void>;
    executeSqlBatch: (queries: import("./types").PreparedBatchQueries[]) => Promise<void>;
    initializeDB: () => Promise<boolean>;
}
//# sourceMappingURL=OfflineDB.d.ts.map